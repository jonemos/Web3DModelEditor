{
  "version": 3,
  "sources": ["../../three/examples/jsm/exporters/GLTFExporter.js"],
  "sourcesContent": ["import {\r\n\tBufferAttribute,\r\n\tClampToEdgeWrapping,\r\n\tColor,\r\n\tDoubleSide,\r\n\tInterpolateDiscrete,\r\n\tInterpolateLinear,\r\n\tNoColorSpace,\r\n\tLinearFilter,\r\n\tLinearMipmapLinearFilter,\r\n\tLinearMipmapNearestFilter,\r\n\tMathUtils,\r\n\tMatrix4,\r\n\tMirroredRepeatWrapping,\r\n\tNearestFilter,\r\n\tNearestMipmapLinearFilter,\r\n\tNearestMipmapNearestFilter,\r\n\tPropertyBinding,\r\n\tRGBAFormat,\r\n\tRepeatWrapping,\r\n\tScene,\r\n\tSource,\r\n\tSRGBColorSpace,\r\n\tCompressedTexture,\r\n\tVector3,\r\n\tQuaternion,\r\n\tREVISION\r\n} from 'three';\r\n\r\n/**\r\n * The KHR_mesh_quantization extension allows these extra attribute component types\r\n *\r\n * @see https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_mesh_quantization/README.md#extending-mesh-attributes\r\n */\r\nconst KHR_mesh_quantization_ExtraAttrTypes = {\r\n\tPOSITION: [\r\n\t\t'byte',\r\n\t\t'byte normalized',\r\n\t\t'unsigned byte',\r\n\t\t'unsigned byte normalized',\r\n\t\t'short',\r\n\t\t'short normalized',\r\n\t\t'unsigned short',\r\n\t\t'unsigned short normalized',\r\n\t],\r\n\tNORMAL: [\r\n\t\t'byte normalized',\r\n\t\t'short normalized',\r\n\t],\r\n\tTANGENT: [\r\n\t\t'byte normalized',\r\n\t\t'short normalized',\r\n\t],\r\n\tTEXCOORD: [\r\n\t\t'byte',\r\n\t\t'byte normalized',\r\n\t\t'unsigned byte',\r\n\t\t'short',\r\n\t\t'short normalized',\r\n\t\t'unsigned short',\r\n\t],\r\n};\r\n\r\n\r\nclass GLTFExporter {\r\n\r\n\tconstructor() {\r\n\r\n\t\tthis.textureUtils = null;\r\n\r\n\t\tthis.pluginCallbacks = [];\r\n\r\n\t\tthis.register( function ( writer ) {\r\n\r\n\t\t\treturn new GLTFLightExtension( writer );\r\n\r\n\t\t} );\r\n\r\n\t\tthis.register( function ( writer ) {\r\n\r\n\t\t\treturn new GLTFMaterialsUnlitExtension( writer );\r\n\r\n\t\t} );\r\n\r\n\t\tthis.register( function ( writer ) {\r\n\r\n\t\t\treturn new GLTFMaterialsTransmissionExtension( writer );\r\n\r\n\t\t} );\r\n\r\n\t\tthis.register( function ( writer ) {\r\n\r\n\t\t\treturn new GLTFMaterialsVolumeExtension( writer );\r\n\r\n\t\t} );\r\n\r\n\t\tthis.register( function ( writer ) {\r\n\r\n\t\t\treturn new GLTFMaterialsIorExtension( writer );\r\n\r\n\t\t} );\r\n\r\n\t\tthis.register( function ( writer ) {\r\n\r\n\t\t\treturn new GLTFMaterialsSpecularExtension( writer );\r\n\r\n\t\t} );\r\n\r\n\t\tthis.register( function ( writer ) {\r\n\r\n\t\t\treturn new GLTFMaterialsClearcoatExtension( writer );\r\n\r\n\t\t} );\r\n\r\n\t\tthis.register( function ( writer ) {\r\n\r\n\t\t\treturn new GLTFMaterialsDispersionExtension( writer );\r\n\r\n\t\t} );\r\n\r\n\t\tthis.register( function ( writer ) {\r\n\r\n\t\t\treturn new GLTFMaterialsIridescenceExtension( writer );\r\n\r\n\t\t} );\r\n\r\n\t\tthis.register( function ( writer ) {\r\n\r\n\t\t\treturn new GLTFMaterialsSheenExtension( writer );\r\n\r\n\t\t} );\r\n\r\n\t\tthis.register( function ( writer ) {\r\n\r\n\t\t\treturn new GLTFMaterialsAnisotropyExtension( writer );\r\n\r\n\t\t} );\r\n\r\n\t\tthis.register( function ( writer ) {\r\n\r\n\t\t\treturn new GLTFMaterialsEmissiveStrengthExtension( writer );\r\n\r\n\t\t} );\r\n\r\n\t\tthis.register( function ( writer ) {\r\n\r\n\t\t\treturn new GLTFMaterialsBumpExtension( writer );\r\n\r\n\t\t} );\r\n\r\n\t\tthis.register( function ( writer ) {\r\n\r\n\t\t\treturn new GLTFMeshGpuInstancing( writer );\r\n\r\n\t\t} );\r\n\r\n\t}\r\n\r\n\tregister( callback ) {\r\n\r\n\t\tif ( this.pluginCallbacks.indexOf( callback ) === - 1 ) {\r\n\r\n\t\t\tthis.pluginCallbacks.push( callback );\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tunregister( callback ) {\r\n\r\n\t\tif ( this.pluginCallbacks.indexOf( callback ) !== - 1 ) {\r\n\r\n\t\t\tthis.pluginCallbacks.splice( this.pluginCallbacks.indexOf( callback ), 1 );\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tsetTextureUtils( utils ) {\r\n\r\n\t\tthis.textureUtils = utils;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Parse scenes and generate GLTF output\r\n\t * @param  {Scene or [THREE.Scenes]} input   Scene or Array of THREE.Scenes\r\n\t * @param  {Function} onDone  Callback on completed\r\n\t * @param  {Function} onError  Callback on errors\r\n\t * @param  {Object} options options\r\n\t */\r\n\tparse( input, onDone, onError, options ) {\r\n\r\n\t\tconst writer = new GLTFWriter();\r\n\t\tconst plugins = [];\r\n\r\n\t\tfor ( let i = 0, il = this.pluginCallbacks.length; i < il; i ++ ) {\r\n\r\n\t\t\tplugins.push( this.pluginCallbacks[ i ]( writer ) );\r\n\r\n\t\t}\r\n\r\n\t\twriter.setPlugins( plugins );\r\n\t\twriter.setTextureUtils( this.textureUtils );\r\n\t\twriter.writeAsync( input, onDone, options ).catch( onError );\r\n\r\n\t}\r\n\r\n\tparseAsync( input, options ) {\r\n\r\n\t\tconst scope = this;\r\n\r\n\t\treturn new Promise( function ( resolve, reject ) {\r\n\r\n\t\t\tscope.parse( input, resolve, reject, options );\r\n\r\n\t\t} );\r\n\r\n\t}\r\n\r\n}\r\n\r\n//------------------------------------------------------------------------------\r\n// Constants\r\n//------------------------------------------------------------------------------\r\n\r\nconst WEBGL_CONSTANTS = {\r\n\tPOINTS: 0x0000,\r\n\tLINES: 0x0001,\r\n\tLINE_LOOP: 0x0002,\r\n\tLINE_STRIP: 0x0003,\r\n\tTRIANGLES: 0x0004,\r\n\tTRIANGLE_STRIP: 0x0005,\r\n\tTRIANGLE_FAN: 0x0006,\r\n\r\n\tBYTE: 0x1400,\r\n\tUNSIGNED_BYTE: 0x1401,\r\n\tSHORT: 0x1402,\r\n\tUNSIGNED_SHORT: 0x1403,\r\n\tINT: 0x1404,\r\n\tUNSIGNED_INT: 0x1405,\r\n\tFLOAT: 0x1406,\r\n\r\n\tARRAY_BUFFER: 0x8892,\r\n\tELEMENT_ARRAY_BUFFER: 0x8893,\r\n\r\n\tNEAREST: 0x2600,\r\n\tLINEAR: 0x2601,\r\n\tNEAREST_MIPMAP_NEAREST: 0x2700,\r\n\tLINEAR_MIPMAP_NEAREST: 0x2701,\r\n\tNEAREST_MIPMAP_LINEAR: 0x2702,\r\n\tLINEAR_MIPMAP_LINEAR: 0x2703,\r\n\r\n\tCLAMP_TO_EDGE: 33071,\r\n\tMIRRORED_REPEAT: 33648,\r\n\tREPEAT: 10497\r\n};\r\n\r\nconst KHR_MESH_QUANTIZATION = 'KHR_mesh_quantization';\r\n\r\nconst THREE_TO_WEBGL = {};\r\n\r\nTHREE_TO_WEBGL[ NearestFilter ] = WEBGL_CONSTANTS.NEAREST;\r\nTHREE_TO_WEBGL[ NearestMipmapNearestFilter ] = WEBGL_CONSTANTS.NEAREST_MIPMAP_NEAREST;\r\nTHREE_TO_WEBGL[ NearestMipmapLinearFilter ] = WEBGL_CONSTANTS.NEAREST_MIPMAP_LINEAR;\r\nTHREE_TO_WEBGL[ LinearFilter ] = WEBGL_CONSTANTS.LINEAR;\r\nTHREE_TO_WEBGL[ LinearMipmapNearestFilter ] = WEBGL_CONSTANTS.LINEAR_MIPMAP_NEAREST;\r\nTHREE_TO_WEBGL[ LinearMipmapLinearFilter ] = WEBGL_CONSTANTS.LINEAR_MIPMAP_LINEAR;\r\n\r\nTHREE_TO_WEBGL[ ClampToEdgeWrapping ] = WEBGL_CONSTANTS.CLAMP_TO_EDGE;\r\nTHREE_TO_WEBGL[ RepeatWrapping ] = WEBGL_CONSTANTS.REPEAT;\r\nTHREE_TO_WEBGL[ MirroredRepeatWrapping ] = WEBGL_CONSTANTS.MIRRORED_REPEAT;\r\n\r\nconst PATH_PROPERTIES = {\r\n\tscale: 'scale',\r\n\tposition: 'translation',\r\n\tquaternion: 'rotation',\r\n\tmorphTargetInfluences: 'weights'\r\n};\r\n\r\nconst DEFAULT_SPECULAR_COLOR = new Color();\r\n\r\n// GLB constants\r\n// https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#glb-file-format-specification\r\n\r\nconst GLB_HEADER_BYTES = 12;\r\nconst GLB_HEADER_MAGIC = 0x46546C67;\r\nconst GLB_VERSION = 2;\r\n\r\nconst GLB_CHUNK_PREFIX_BYTES = 8;\r\nconst GLB_CHUNK_TYPE_JSON = 0x4E4F534A;\r\nconst GLB_CHUNK_TYPE_BIN = 0x004E4942;\r\n\r\n//------------------------------------------------------------------------------\r\n// Utility functions\r\n//------------------------------------------------------------------------------\r\n\r\n/**\r\n * Compare two arrays\r\n * @param  {Array} array1 Array 1 to compare\r\n * @param  {Array} array2 Array 2 to compare\r\n * @return {Boolean}        Returns true if both arrays are equal\r\n */\r\nfunction equalArray( array1, array2 ) {\r\n\r\n\treturn ( array1.length === array2.length ) && array1.every( function ( element, index ) {\r\n\r\n\t\treturn element === array2[ index ];\r\n\r\n\t} );\r\n\r\n}\r\n\r\n/**\r\n * Converts a string to an ArrayBuffer.\r\n * @param  {string} text\r\n * @return {ArrayBuffer}\r\n */\r\nfunction stringToArrayBuffer( text ) {\r\n\r\n\treturn new TextEncoder().encode( text ).buffer;\r\n\r\n}\r\n\r\n/**\r\n * Is identity matrix\r\n *\r\n * @param {Matrix4} matrix\r\n * @returns {Boolean} Returns true, if parameter is identity matrix\r\n */\r\nfunction isIdentityMatrix( matrix ) {\r\n\r\n\treturn equalArray( matrix.elements, [ 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1 ] );\r\n\r\n}\r\n\r\n/**\r\n * Get the min and max vectors from the given attribute\r\n * @param  {BufferAttribute} attribute Attribute to find the min/max in range from start to start + count\r\n * @param  {Integer} start\r\n * @param  {Integer} count\r\n * @return {Object} Object containing the `min` and `max` values (As an array of attribute.itemSize components)\r\n */\r\nfunction getMinMax( attribute, start, count ) {\r\n\r\n\tconst output = {\r\n\r\n\t\tmin: new Array( attribute.itemSize ).fill( Number.POSITIVE_INFINITY ),\r\n\t\tmax: new Array( attribute.itemSize ).fill( Number.NEGATIVE_INFINITY )\r\n\r\n\t};\r\n\r\n\tfor ( let i = start; i < start + count; i ++ ) {\r\n\r\n\t\tfor ( let a = 0; a < attribute.itemSize; a ++ ) {\r\n\r\n\t\t\tlet value;\r\n\r\n\t\t\tif ( attribute.itemSize > 4 ) {\r\n\r\n\t\t\t\t // no support for interleaved data for itemSize > 4\r\n\r\n\t\t\t\tvalue = attribute.array[ i * attribute.itemSize + a ];\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tif ( a === 0 ) value = attribute.getX( i );\r\n\t\t\t\telse if ( a === 1 ) value = attribute.getY( i );\r\n\t\t\t\telse if ( a === 2 ) value = attribute.getZ( i );\r\n\t\t\t\telse if ( a === 3 ) value = attribute.getW( i );\r\n\r\n\t\t\t\tif ( attribute.normalized === true ) {\r\n\r\n\t\t\t\t\tvalue = MathUtils.normalize( value, attribute.array );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\toutput.min[ a ] = Math.min( output.min[ a ], value );\r\n\t\t\toutput.max[ a ] = Math.max( output.max[ a ], value );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treturn output;\r\n\r\n}\r\n\r\n/**\r\n * Get the required size + padding for a buffer, rounded to the next 4-byte boundary.\r\n * https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#data-alignment\r\n *\r\n * @param {Integer} bufferSize The size the original buffer.\r\n * @returns {Integer} new buffer size with required padding.\r\n *\r\n */\r\nfunction getPaddedBufferSize( bufferSize ) {\r\n\r\n\treturn Math.ceil( bufferSize / 4 ) * 4;\r\n\r\n}\r\n\r\n/**\r\n * Returns a buffer aligned to 4-byte boundary.\r\n *\r\n * @param {ArrayBuffer} arrayBuffer Buffer to pad\r\n * @param {Integer} paddingByte (Optional)\r\n * @returns {ArrayBuffer} The same buffer if it's already aligned to 4-byte boundary or a new buffer\r\n */\r\nfunction getPaddedArrayBuffer( arrayBuffer, paddingByte = 0 ) {\r\n\r\n\tconst paddedLength = getPaddedBufferSize( arrayBuffer.byteLength );\r\n\r\n\tif ( paddedLength !== arrayBuffer.byteLength ) {\r\n\r\n\t\tconst array = new Uint8Array( paddedLength );\r\n\t\tarray.set( new Uint8Array( arrayBuffer ) );\r\n\r\n\t\tif ( paddingByte !== 0 ) {\r\n\r\n\t\t\tfor ( let i = arrayBuffer.byteLength; i < paddedLength; i ++ ) {\r\n\r\n\t\t\t\tarray[ i ] = paddingByte;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn array.buffer;\r\n\r\n\t}\r\n\r\n\treturn arrayBuffer;\r\n\r\n}\r\n\r\nfunction getCanvas() {\r\n\r\n\tif ( typeof document === 'undefined' && typeof OffscreenCanvas !== 'undefined' ) {\r\n\r\n\t\treturn new OffscreenCanvas( 1, 1 );\r\n\r\n\t}\r\n\r\n\treturn document.createElement( 'canvas' );\r\n\r\n}\r\n\r\nfunction getToBlobPromise( canvas, mimeType ) {\r\n\r\n\tif ( canvas.toBlob !== undefined ) {\r\n\r\n\t\treturn new Promise( ( resolve ) => canvas.toBlob( resolve, mimeType ) );\r\n\r\n\t}\r\n\r\n\tlet quality;\r\n\r\n\t// Blink's implementation of convertToBlob seems to default to a quality level of 100%\r\n\t// Use the Blink default quality levels of toBlob instead so that file sizes are comparable.\r\n\tif ( mimeType === 'image/jpeg' ) {\r\n\r\n\t\tquality = 0.92;\r\n\r\n\t} else if ( mimeType === 'image/webp' ) {\r\n\r\n\t\tquality = 0.8;\r\n\r\n\t}\r\n\r\n\treturn canvas.convertToBlob( {\r\n\r\n\t\ttype: mimeType,\r\n\t\tquality: quality\r\n\r\n\t} );\r\n\r\n}\r\n\r\n/**\r\n * Writer\r\n */\r\nclass GLTFWriter {\r\n\r\n\tconstructor() {\r\n\r\n\t\tthis.plugins = [];\r\n\r\n\t\tthis.options = {};\r\n\t\tthis.pending = [];\r\n\t\tthis.buffers = [];\r\n\r\n\t\tthis.byteOffset = 0;\r\n\t\tthis.buffers = [];\r\n\t\tthis.nodeMap = new Map();\r\n\t\tthis.skins = [];\r\n\r\n\t\tthis.extensionsUsed = {};\r\n\t\tthis.extensionsRequired = {};\r\n\r\n\t\tthis.uids = new Map();\r\n\t\tthis.uid = 0;\r\n\r\n\t\tthis.json = {\r\n\t\t\tasset: {\r\n\t\t\t\tversion: '2.0',\r\n\t\t\t\tgenerator: 'THREE.GLTFExporter r' + REVISION\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tthis.cache = {\r\n\t\t\tmeshes: new Map(),\r\n\t\t\tattributes: new Map(),\r\n\t\t\tattributesNormalized: new Map(),\r\n\t\t\tmaterials: new Map(),\r\n\t\t\ttextures: new Map(),\r\n\t\t\timages: new Map()\r\n\t\t};\r\n\r\n\t\tthis.textureUtils = null;\r\n\r\n\t}\r\n\r\n\tsetPlugins( plugins ) {\r\n\r\n\t\tthis.plugins = plugins;\r\n\r\n\t}\r\n\r\n\tsetTextureUtils( utils ) {\r\n\r\n\t\tthis.textureUtils = utils;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Parse scenes and generate GLTF output\r\n\t * @param  {Scene or [THREE.Scenes]} input   Scene or Array of THREE.Scenes\r\n\t * @param  {Function} onDone  Callback on completed\r\n\t * @param  {Object} options options\r\n\t */\r\n\tasync writeAsync( input, onDone, options = {} ) {\r\n\r\n\t\tthis.options = Object.assign( {\r\n\t\t\t// default options\r\n\t\t\tbinary: false,\r\n\t\t\ttrs: false,\r\n\t\t\tonlyVisible: true,\r\n\t\t\tmaxTextureSize: Infinity,\r\n\t\t\tanimations: [],\r\n\t\t\tincludeCustomExtensions: false\r\n\t\t}, options );\r\n\r\n\t\tif ( this.options.animations.length > 0 ) {\r\n\r\n\t\t\t// Only TRS properties, and not matrices, may be targeted by animation.\r\n\t\t\tthis.options.trs = true;\r\n\r\n\t\t}\r\n\r\n\t\tawait this.processInputAsync( input );\r\n\r\n\t\tawait Promise.all( this.pending );\r\n\r\n\t\tconst writer = this;\r\n\t\tconst buffers = writer.buffers;\r\n\t\tconst json = writer.json;\r\n\t\toptions = writer.options;\r\n\r\n\t\tconst extensionsUsed = writer.extensionsUsed;\r\n\t\tconst extensionsRequired = writer.extensionsRequired;\r\n\r\n\t\t// Merge buffers.\r\n\t\tconst blob = new Blob( buffers, { type: 'application/octet-stream' } );\r\n\r\n\t\t// Declare extensions.\r\n\t\tconst extensionsUsedList = Object.keys( extensionsUsed );\r\n\t\tconst extensionsRequiredList = Object.keys( extensionsRequired );\r\n\r\n\t\tif ( extensionsUsedList.length > 0 ) json.extensionsUsed = extensionsUsedList;\r\n\t\tif ( extensionsRequiredList.length > 0 ) json.extensionsRequired = extensionsRequiredList;\r\n\r\n\t\t// Update bytelength of the single buffer.\r\n\t\tif ( json.buffers && json.buffers.length > 0 ) json.buffers[ 0 ].byteLength = blob.size;\r\n\r\n\t\tif ( options.binary === true ) {\r\n\r\n\t\t\t// https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#glb-file-format-specification\r\n\r\n\t\t\tconst reader = new FileReader();\r\n\t\t\treader.readAsArrayBuffer( blob );\r\n\t\t\treader.onloadend = function () {\r\n\r\n\t\t\t\t// Binary chunk.\r\n\t\t\t\tconst binaryChunk = getPaddedArrayBuffer( reader.result );\r\n\t\t\t\tconst binaryChunkPrefix = new DataView( new ArrayBuffer( GLB_CHUNK_PREFIX_BYTES ) );\r\n\t\t\t\tbinaryChunkPrefix.setUint32( 0, binaryChunk.byteLength, true );\r\n\t\t\t\tbinaryChunkPrefix.setUint32( 4, GLB_CHUNK_TYPE_BIN, true );\r\n\r\n\t\t\t\t// JSON chunk.\r\n\t\t\t\tconst jsonChunk = getPaddedArrayBuffer( stringToArrayBuffer( JSON.stringify( json ) ), 0x20 );\r\n\t\t\t\tconst jsonChunkPrefix = new DataView( new ArrayBuffer( GLB_CHUNK_PREFIX_BYTES ) );\r\n\t\t\t\tjsonChunkPrefix.setUint32( 0, jsonChunk.byteLength, true );\r\n\t\t\t\tjsonChunkPrefix.setUint32( 4, GLB_CHUNK_TYPE_JSON, true );\r\n\r\n\t\t\t\t// GLB header.\r\n\t\t\t\tconst header = new ArrayBuffer( GLB_HEADER_BYTES );\r\n\t\t\t\tconst headerView = new DataView( header );\r\n\t\t\t\theaderView.setUint32( 0, GLB_HEADER_MAGIC, true );\r\n\t\t\t\theaderView.setUint32( 4, GLB_VERSION, true );\r\n\t\t\t\tconst totalByteLength = GLB_HEADER_BYTES\r\n\t\t\t\t\t+ jsonChunkPrefix.byteLength + jsonChunk.byteLength\r\n\t\t\t\t\t+ binaryChunkPrefix.byteLength + binaryChunk.byteLength;\r\n\t\t\t\theaderView.setUint32( 8, totalByteLength, true );\r\n\r\n\t\t\t\tconst glbBlob = new Blob( [\r\n\t\t\t\t\theader,\r\n\t\t\t\t\tjsonChunkPrefix,\r\n\t\t\t\t\tjsonChunk,\r\n\t\t\t\t\tbinaryChunkPrefix,\r\n\t\t\t\t\tbinaryChunk\r\n\t\t\t\t], { type: 'application/octet-stream' } );\r\n\r\n\t\t\t\tconst glbReader = new FileReader();\r\n\t\t\t\tglbReader.readAsArrayBuffer( glbBlob );\r\n\t\t\t\tglbReader.onloadend = function () {\r\n\r\n\t\t\t\t\tonDone( glbReader.result );\r\n\r\n\t\t\t\t};\r\n\r\n\t\t\t};\r\n\r\n\t\t} else {\r\n\r\n\t\t\tif ( json.buffers && json.buffers.length > 0 ) {\r\n\r\n\t\t\t\tconst reader = new FileReader();\r\n\t\t\t\treader.readAsDataURL( blob );\r\n\t\t\t\treader.onloadend = function () {\r\n\r\n\t\t\t\t\tconst base64data = reader.result;\r\n\t\t\t\t\tjson.buffers[ 0 ].uri = base64data;\r\n\t\t\t\t\tonDone( json );\r\n\r\n\t\t\t\t};\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tonDone( json );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Serializes a userData.\r\n\t *\r\n\t * @param {THREE.Object3D|THREE.Material} object\r\n\t * @param {Object} objectDef\r\n\t */\r\n\tserializeUserData( object, objectDef ) {\r\n\r\n\t\tif ( Object.keys( object.userData ).length === 0 ) return;\r\n\r\n\t\tconst options = this.options;\r\n\t\tconst extensionsUsed = this.extensionsUsed;\r\n\r\n\t\ttry {\r\n\r\n\t\t\tconst json = JSON.parse( JSON.stringify( object.userData ) );\r\n\r\n\t\t\tif ( options.includeCustomExtensions && json.gltfExtensions ) {\r\n\r\n\t\t\t\tif ( objectDef.extensions === undefined ) objectDef.extensions = {};\r\n\r\n\t\t\t\tfor ( const extensionName in json.gltfExtensions ) {\r\n\r\n\t\t\t\t\tobjectDef.extensions[ extensionName ] = json.gltfExtensions[ extensionName ];\r\n\t\t\t\t\textensionsUsed[ extensionName ] = true;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tdelete json.gltfExtensions;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( Object.keys( json ).length > 0 ) objectDef.extras = json;\r\n\r\n\t\t} catch ( error ) {\r\n\r\n\t\t\tconsole.warn( 'THREE.GLTFExporter: userData of \\'' + object.name + '\\' ' +\r\n\t\t\t\t'won\\'t be serialized because of JSON.stringify error - ' + error.message );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Returns ids for buffer attributes.\r\n\t * @param  {Object} object\r\n\t * @return {Integer}\r\n\t */\r\n\tgetUID( attribute, isRelativeCopy = false ) {\r\n\r\n\t\tif ( this.uids.has( attribute ) === false ) {\r\n\r\n\t\t\tconst uids = new Map();\r\n\r\n\t\t\tuids.set( true, this.uid ++ );\r\n\t\t\tuids.set( false, this.uid ++ );\r\n\r\n\t\t\tthis.uids.set( attribute, uids );\r\n\r\n\t\t}\r\n\r\n\t\tconst uids = this.uids.get( attribute );\r\n\r\n\t\treturn uids.get( isRelativeCopy );\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Checks if normal attribute values are normalized.\r\n\t *\r\n\t * @param {BufferAttribute} normal\r\n\t * @returns {Boolean}\r\n\t */\r\n\tisNormalizedNormalAttribute( normal ) {\r\n\r\n\t\tconst cache = this.cache;\r\n\r\n\t\tif ( cache.attributesNormalized.has( normal ) ) return false;\r\n\r\n\t\tconst v = new Vector3();\r\n\r\n\t\tfor ( let i = 0, il = normal.count; i < il; i ++ ) {\r\n\r\n\t\t\t// 0.0005 is from glTF-validator\r\n\t\t\tif ( Math.abs( v.fromBufferAttribute( normal, i ).length() - 1.0 ) > 0.0005 ) return false;\r\n\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Creates normalized normal buffer attribute.\r\n\t *\r\n\t * @param {BufferAttribute} normal\r\n\t * @returns {BufferAttribute}\r\n\t *\r\n\t */\r\n\tcreateNormalizedNormalAttribute( normal ) {\r\n\r\n\t\tconst cache = this.cache;\r\n\r\n\t\tif ( cache.attributesNormalized.has( normal ) )\treturn cache.attributesNormalized.get( normal );\r\n\r\n\t\tconst attribute = normal.clone();\r\n\t\tconst v = new Vector3();\r\n\r\n\t\tfor ( let i = 0, il = attribute.count; i < il; i ++ ) {\r\n\r\n\t\t\tv.fromBufferAttribute( attribute, i );\r\n\r\n\t\t\tif ( v.x === 0 && v.y === 0 && v.z === 0 ) {\r\n\r\n\t\t\t\t// if values can't be normalized set (1, 0, 0)\r\n\t\t\t\tv.setX( 1.0 );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tv.normalize();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tattribute.setXYZ( i, v.x, v.y, v.z );\r\n\r\n\t\t}\r\n\r\n\t\tcache.attributesNormalized.set( normal, attribute );\r\n\r\n\t\treturn attribute;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Applies a texture transform, if present, to the map definition. Requires\r\n\t * the KHR_texture_transform extension.\r\n\t *\r\n\t * @param {Object} mapDef\r\n\t * @param {THREE.Texture} texture\r\n\t */\r\n\tapplyTextureTransform( mapDef, texture ) {\r\n\r\n\t\tlet didTransform = false;\r\n\t\tconst transformDef = {};\r\n\r\n\t\tif ( texture.offset.x !== 0 || texture.offset.y !== 0 ) {\r\n\r\n\t\t\ttransformDef.offset = texture.offset.toArray();\r\n\t\t\tdidTransform = true;\r\n\r\n\t\t}\r\n\r\n\t\tif ( texture.rotation !== 0 ) {\r\n\r\n\t\t\ttransformDef.rotation = texture.rotation;\r\n\t\t\tdidTransform = true;\r\n\r\n\t\t}\r\n\r\n\t\tif ( texture.repeat.x !== 1 || texture.repeat.y !== 1 ) {\r\n\r\n\t\t\ttransformDef.scale = texture.repeat.toArray();\r\n\t\t\tdidTransform = true;\r\n\r\n\t\t}\r\n\r\n\t\tif ( didTransform ) {\r\n\r\n\t\t\tmapDef.extensions = mapDef.extensions || {};\r\n\t\t\tmapDef.extensions[ 'KHR_texture_transform' ] = transformDef;\r\n\t\t\tthis.extensionsUsed[ 'KHR_texture_transform' ] = true;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tasync buildMetalRoughTextureAsync( metalnessMap, roughnessMap ) {\r\n\r\n\t\tif ( metalnessMap === roughnessMap ) return metalnessMap;\r\n\r\n\t\tfunction getEncodingConversion( map ) {\r\n\r\n\t\t\tif ( map.colorSpace === SRGBColorSpace ) {\r\n\r\n\t\t\t\treturn function SRGBToLinear( c ) {\r\n\r\n\t\t\t\t\treturn ( c < 0.04045 ) ? c * 0.0773993808 : Math.pow( c * 0.9478672986 + 0.0521327014, 2.4 );\r\n\r\n\t\t\t\t};\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn function LinearToLinear( c ) {\r\n\r\n\t\t\t\treturn c;\r\n\r\n\t\t\t};\r\n\r\n\t\t}\r\n\r\n\t\tif ( metalnessMap instanceof CompressedTexture ) {\r\n\r\n\t\t\tmetalnessMap = await this.decompressTextureAsync( metalnessMap );\r\n\r\n\t\t}\r\n\r\n\t\tif ( roughnessMap instanceof CompressedTexture ) {\r\n\r\n\t\t\troughnessMap = await this.decompressTextureAsync( roughnessMap );\r\n\r\n\t\t}\r\n\r\n\t\tconst metalness = metalnessMap ? metalnessMap.image : null;\r\n\t\tconst roughness = roughnessMap ? roughnessMap.image : null;\r\n\r\n\t\tconst width = Math.max( metalness ? metalness.width : 0, roughness ? roughness.width : 0 );\r\n\t\tconst height = Math.max( metalness ? metalness.height : 0, roughness ? roughness.height : 0 );\r\n\r\n\t\tconst canvas = getCanvas();\r\n\t\tcanvas.width = width;\r\n\t\tcanvas.height = height;\r\n\r\n\t\tconst context = canvas.getContext( '2d', {\r\n\t\t\twillReadFrequently: true,\r\n\t\t} );\r\n\t\tcontext.fillStyle = '#00ffff';\r\n\t\tcontext.fillRect( 0, 0, width, height );\r\n\r\n\t\tconst composite = context.getImageData( 0, 0, width, height );\r\n\r\n\t\tif ( metalness ) {\r\n\r\n\t\t\tcontext.drawImage( metalness, 0, 0, width, height );\r\n\r\n\t\t\tconst convert = getEncodingConversion( metalnessMap );\r\n\t\t\tconst data = context.getImageData( 0, 0, width, height ).data;\r\n\r\n\t\t\tfor ( let i = 2; i < data.length; i += 4 ) {\r\n\r\n\t\t\t\tcomposite.data[ i ] = convert( data[ i ] / 256 ) * 256;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( roughness ) {\r\n\r\n\t\t\tcontext.drawImage( roughness, 0, 0, width, height );\r\n\r\n\t\t\tconst convert = getEncodingConversion( roughnessMap );\r\n\t\t\tconst data = context.getImageData( 0, 0, width, height ).data;\r\n\r\n\t\t\tfor ( let i = 1; i < data.length; i += 4 ) {\r\n\r\n\t\t\t\tcomposite.data[ i ] = convert( data[ i ] / 256 ) * 256;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tcontext.putImageData( composite, 0, 0 );\r\n\r\n\t\t//\r\n\r\n\t\tconst reference = metalnessMap || roughnessMap;\r\n\r\n\t\tconst texture = reference.clone();\r\n\r\n\t\ttexture.source = new Source( canvas );\r\n\t\ttexture.colorSpace = NoColorSpace;\r\n\t\ttexture.channel = ( metalnessMap || roughnessMap ).channel;\r\n\r\n\t\tif ( metalnessMap && roughnessMap && metalnessMap.channel !== roughnessMap.channel ) {\r\n\r\n\t\t\tconsole.warn( 'THREE.GLTFExporter: UV channels for metalnessMap and roughnessMap textures must match.' );\r\n\r\n\t\t}\r\n\r\n\t\tconsole.warn( 'THREE.GLTFExporter: Merged metalnessMap and roughnessMap textures.' );\r\n\r\n\t\treturn texture;\r\n\r\n\t}\r\n\r\n\r\n\tasync decompressTextureAsync( texture, maxTextureSize = Infinity ) {\r\n\r\n\t\tif ( this.textureUtils === null ) {\r\n\r\n\t\t\tthrow new Error( 'THREE.GLTFExporter: setTextureUtils() must be called to process compressed textures.' );\r\n\r\n\t\t}\r\n\r\n\t\treturn await this.textureUtils.decompress( texture, maxTextureSize );\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Process a buffer to append to the default one.\r\n\t * @param  {ArrayBuffer} buffer\r\n\t * @return {Integer}\r\n\t */\r\n\tprocessBuffer( buffer ) {\r\n\r\n\t\tconst json = this.json;\r\n\t\tconst buffers = this.buffers;\r\n\r\n\t\tif ( ! json.buffers ) json.buffers = [ { byteLength: 0 } ];\r\n\r\n\t\t// All buffers are merged before export.\r\n\t\tbuffers.push( buffer );\r\n\r\n\t\treturn 0;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Process and generate a BufferView\r\n\t * @param  {BufferAttribute} attribute\r\n\t * @param  {number} componentType\r\n\t * @param  {number} start\r\n\t * @param  {number} count\r\n\t * @param  {number} target (Optional) Target usage of the BufferView\r\n\t * @return {Object}\r\n\t */\r\n\tprocessBufferView( attribute, componentType, start, count, target ) {\r\n\r\n\t\tconst json = this.json;\r\n\r\n\t\tif ( ! json.bufferViews ) json.bufferViews = [];\r\n\r\n\t\t// Create a new dataview and dump the attribute's array into it\r\n\r\n\t\tlet componentSize;\r\n\r\n\t\tswitch ( componentType ) {\r\n\r\n\t\t\tcase WEBGL_CONSTANTS.BYTE:\r\n\t\t\tcase WEBGL_CONSTANTS.UNSIGNED_BYTE:\r\n\r\n\t\t\t\tcomponentSize = 1;\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase WEBGL_CONSTANTS.SHORT:\r\n\t\t\tcase WEBGL_CONSTANTS.UNSIGNED_SHORT:\r\n\r\n\t\t\t\tcomponentSize = 2;\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tdefault:\r\n\r\n\t\t\t\tcomponentSize = 4;\r\n\r\n\t\t}\r\n\r\n\t\tlet byteStride = attribute.itemSize * componentSize;\r\n\r\n\t\tif ( target === WEBGL_CONSTANTS.ARRAY_BUFFER ) {\r\n\r\n\t\t\t// Each element of a vertex attribute MUST be aligned to 4-byte boundaries\r\n\t\t\t// inside a bufferView\r\n\t\t\tbyteStride = Math.ceil( byteStride / 4 ) * 4;\r\n\r\n\t\t}\r\n\r\n\t\tconst byteLength = getPaddedBufferSize( count * byteStride );\r\n\t\tconst dataView = new DataView( new ArrayBuffer( byteLength ) );\r\n\t\tlet offset = 0;\r\n\r\n\t\tfor ( let i = start; i < start + count; i ++ ) {\r\n\r\n\t\t\tfor ( let a = 0; a < attribute.itemSize; a ++ ) {\r\n\r\n\t\t\t\tlet value;\r\n\r\n\t\t\t\tif ( attribute.itemSize > 4 ) {\r\n\r\n\t\t\t\t\t // no support for interleaved data for itemSize > 4\r\n\r\n\t\t\t\t\tvalue = attribute.array[ i * attribute.itemSize + a ];\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tif ( a === 0 ) value = attribute.getX( i );\r\n\t\t\t\t\telse if ( a === 1 ) value = attribute.getY( i );\r\n\t\t\t\t\telse if ( a === 2 ) value = attribute.getZ( i );\r\n\t\t\t\t\telse if ( a === 3 ) value = attribute.getW( i );\r\n\r\n\t\t\t\t\tif ( attribute.normalized === true ) {\r\n\r\n\t\t\t\t\t\tvalue = MathUtils.normalize( value, attribute.array );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( componentType === WEBGL_CONSTANTS.FLOAT ) {\r\n\r\n\t\t\t\t\tdataView.setFloat32( offset, value, true );\r\n\r\n\t\t\t\t} else if ( componentType === WEBGL_CONSTANTS.INT ) {\r\n\r\n\t\t\t\t\tdataView.setInt32( offset, value, true );\r\n\r\n\t\t\t\t} else if ( componentType === WEBGL_CONSTANTS.UNSIGNED_INT ) {\r\n\r\n\t\t\t\t\tdataView.setUint32( offset, value, true );\r\n\r\n\t\t\t\t} else if ( componentType === WEBGL_CONSTANTS.SHORT ) {\r\n\r\n\t\t\t\t\tdataView.setInt16( offset, value, true );\r\n\r\n\t\t\t\t} else if ( componentType === WEBGL_CONSTANTS.UNSIGNED_SHORT ) {\r\n\r\n\t\t\t\t\tdataView.setUint16( offset, value, true );\r\n\r\n\t\t\t\t} else if ( componentType === WEBGL_CONSTANTS.BYTE ) {\r\n\r\n\t\t\t\t\tdataView.setInt8( offset, value );\r\n\r\n\t\t\t\t} else if ( componentType === WEBGL_CONSTANTS.UNSIGNED_BYTE ) {\r\n\r\n\t\t\t\t\tdataView.setUint8( offset, value );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\toffset += componentSize;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( ( offset % byteStride ) !== 0 ) {\r\n\r\n\t\t\t\toffset += byteStride - ( offset % byteStride );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tconst bufferViewDef = {\r\n\r\n\t\t\tbuffer: this.processBuffer( dataView.buffer ),\r\n\t\t\tbyteOffset: this.byteOffset,\r\n\t\t\tbyteLength: byteLength\r\n\r\n\t\t};\r\n\r\n\t\tif ( target !== undefined ) bufferViewDef.target = target;\r\n\r\n\t\tif ( target === WEBGL_CONSTANTS.ARRAY_BUFFER ) {\r\n\r\n\t\t\t// Only define byteStride for vertex attributes.\r\n\t\t\tbufferViewDef.byteStride = byteStride;\r\n\r\n\t\t}\r\n\r\n\t\tthis.byteOffset += byteLength;\r\n\r\n\t\tjson.bufferViews.push( bufferViewDef );\r\n\r\n\t\t// @TODO Merge bufferViews where possible.\r\n\t\tconst output = {\r\n\r\n\t\t\tid: json.bufferViews.length - 1,\r\n\t\t\tbyteLength: 0\r\n\r\n\t\t};\r\n\r\n\t\treturn output;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Process and generate a BufferView from an image Blob.\r\n\t * @param {Blob} blob\r\n\t * @return {Promise<Integer>}\r\n\t */\r\n\tprocessBufferViewImage( blob ) {\r\n\r\n\t\tconst writer = this;\r\n\t\tconst json = writer.json;\r\n\r\n\t\tif ( ! json.bufferViews ) json.bufferViews = [];\r\n\r\n\t\treturn new Promise( function ( resolve ) {\r\n\r\n\t\t\tconst reader = new FileReader();\r\n\t\t\treader.readAsArrayBuffer( blob );\r\n\t\t\treader.onloadend = function () {\r\n\r\n\t\t\t\tconst buffer = getPaddedArrayBuffer( reader.result );\r\n\r\n\t\t\t\tconst bufferViewDef = {\r\n\t\t\t\t\tbuffer: writer.processBuffer( buffer ),\r\n\t\t\t\t\tbyteOffset: writer.byteOffset,\r\n\t\t\t\t\tbyteLength: buffer.byteLength\r\n\t\t\t\t};\r\n\r\n\t\t\t\twriter.byteOffset += buffer.byteLength;\r\n\t\t\t\tresolve( json.bufferViews.push( bufferViewDef ) - 1 );\r\n\r\n\t\t\t};\r\n\r\n\t\t} );\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Process attribute to generate an accessor\r\n\t * @param  {BufferAttribute} attribute Attribute to process\r\n\t * @param  {THREE.BufferGeometry} geometry (Optional) Geometry used for truncated draw range\r\n\t * @param  {Integer} start (Optional)\r\n\t * @param  {Integer} count (Optional)\r\n\t * @return {Integer|null} Index of the processed accessor on the \"accessors\" array\r\n\t */\r\n\tprocessAccessor( attribute, geometry, start, count ) {\r\n\r\n\t\tconst json = this.json;\r\n\r\n\t\tconst types = {\r\n\r\n\t\t\t1: 'SCALAR',\r\n\t\t\t2: 'VEC2',\r\n\t\t\t3: 'VEC3',\r\n\t\t\t4: 'VEC4',\r\n\t\t\t9: 'MAT3',\r\n\t\t\t16: 'MAT4'\r\n\r\n\t\t};\r\n\r\n\t\tlet componentType;\r\n\r\n\t\t// Detect the component type of the attribute array\r\n\t\tif ( attribute.array.constructor === Float32Array ) {\r\n\r\n\t\t\tcomponentType = WEBGL_CONSTANTS.FLOAT;\r\n\r\n\t\t} else if ( attribute.array.constructor === Int32Array ) {\r\n\r\n\t\t\tcomponentType = WEBGL_CONSTANTS.INT;\r\n\r\n\t\t} else if ( attribute.array.constructor === Uint32Array ) {\r\n\r\n\t\t\tcomponentType = WEBGL_CONSTANTS.UNSIGNED_INT;\r\n\r\n\t\t} else if ( attribute.array.constructor === Int16Array ) {\r\n\r\n\t\t\tcomponentType = WEBGL_CONSTANTS.SHORT;\r\n\r\n\t\t} else if ( attribute.array.constructor === Uint16Array ) {\r\n\r\n\t\t\tcomponentType = WEBGL_CONSTANTS.UNSIGNED_SHORT;\r\n\r\n\t\t} else if ( attribute.array.constructor === Int8Array ) {\r\n\r\n\t\t\tcomponentType = WEBGL_CONSTANTS.BYTE;\r\n\r\n\t\t} else if ( attribute.array.constructor === Uint8Array ) {\r\n\r\n\t\t\tcomponentType = WEBGL_CONSTANTS.UNSIGNED_BYTE;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthrow new Error( 'THREE.GLTFExporter: Unsupported bufferAttribute component type: ' + attribute.array.constructor.name );\r\n\r\n\t\t}\r\n\r\n\t\tif ( start === undefined ) start = 0;\r\n\t\tif ( count === undefined || count === Infinity ) count = attribute.count;\r\n\r\n\t\t// Skip creating an accessor if the attribute doesn't have data to export\r\n\t\tif ( count === 0 ) return null;\r\n\r\n\t\tconst minMax = getMinMax( attribute, start, count );\r\n\t\tlet bufferViewTarget;\r\n\r\n\t\t// If geometry isn't provided, don't infer the target usage of the bufferView. For\r\n\t\t// animation samplers, target must not be set.\r\n\t\tif ( geometry !== undefined ) {\r\n\r\n\t\t\tbufferViewTarget = attribute === geometry.index ? WEBGL_CONSTANTS.ELEMENT_ARRAY_BUFFER : WEBGL_CONSTANTS.ARRAY_BUFFER;\r\n\r\n\t\t}\r\n\r\n\t\tconst bufferView = this.processBufferView( attribute, componentType, start, count, bufferViewTarget );\r\n\r\n\t\tconst accessorDef = {\r\n\r\n\t\t\tbufferView: bufferView.id,\r\n\t\t\tbyteOffset: bufferView.byteOffset,\r\n\t\t\tcomponentType: componentType,\r\n\t\t\tcount: count,\r\n\t\t\tmax: minMax.max,\r\n\t\t\tmin: minMax.min,\r\n\t\t\ttype: types[ attribute.itemSize ]\r\n\r\n\t\t};\r\n\r\n\t\tif ( attribute.normalized === true ) accessorDef.normalized = true;\r\n\t\tif ( ! json.accessors ) json.accessors = [];\r\n\r\n\t\treturn json.accessors.push( accessorDef ) - 1;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Process image\r\n\t * @param  {Image} image to process\r\n\t * @param  {Integer} format of the image (RGBAFormat)\r\n\t * @param  {Boolean} flipY before writing out the image\r\n\t * @param  {String} mimeType export format\r\n\t * @return {Integer}     Index of the processed texture in the \"images\" array\r\n\t */\r\n\tprocessImage( image, format, flipY, mimeType = 'image/png' ) {\r\n\r\n\t\tif ( image !== null ) {\r\n\r\n\t\t\tconst writer = this;\r\n\t\t\tconst cache = writer.cache;\r\n\t\t\tconst json = writer.json;\r\n\t\t\tconst options = writer.options;\r\n\t\t\tconst pending = writer.pending;\r\n\r\n\t\t\tif ( ! cache.images.has( image ) ) cache.images.set( image, {} );\r\n\r\n\t\t\tconst cachedImages = cache.images.get( image );\r\n\r\n\t\t\tconst key = mimeType + ':flipY/' + flipY.toString();\r\n\r\n\t\t\tif ( cachedImages[ key ] !== undefined ) return cachedImages[ key ];\r\n\r\n\t\t\tif ( ! json.images ) json.images = [];\r\n\r\n\t\t\tconst imageDef = { mimeType: mimeType };\r\n\r\n\t\t\tconst canvas = getCanvas();\r\n\r\n\t\t\tcanvas.width = Math.min( image.width, options.maxTextureSize );\r\n\t\t\tcanvas.height = Math.min( image.height, options.maxTextureSize );\r\n\r\n\t\t\tconst ctx = canvas.getContext( '2d', {\r\n\t\t\t\twillReadFrequently: true,\r\n\t\t\t} );\r\n\r\n\t\t\tif ( flipY === true ) {\r\n\r\n\t\t\t\tctx.translate( 0, canvas.height );\r\n\t\t\t\tctx.scale( 1, - 1 );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( image.data !== undefined ) { // THREE.DataTexture\r\n\r\n\t\t\t\tif ( format !== RGBAFormat ) {\r\n\r\n\t\t\t\t\tconsole.error( 'GLTFExporter: Only RGBAFormat is supported.', format );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( image.width > options.maxTextureSize || image.height > options.maxTextureSize ) {\r\n\r\n\t\t\t\t\tconsole.warn( 'GLTFExporter: Image size is bigger than maxTextureSize', image );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tconst data = new Uint8ClampedArray( image.height * image.width * 4 );\r\n\r\n\t\t\t\tfor ( let i = 0; i < data.length; i += 4 ) {\r\n\r\n\t\t\t\t\tdata[ i + 0 ] = image.data[ i + 0 ];\r\n\t\t\t\t\tdata[ i + 1 ] = image.data[ i + 1 ];\r\n\t\t\t\t\tdata[ i + 2 ] = image.data[ i + 2 ];\r\n\t\t\t\t\tdata[ i + 3 ] = image.data[ i + 3 ];\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tctx.putImageData( new ImageData( data, image.width, image.height ), 0, 0 );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tif ( ( typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement ) ||\r\n\t\t\t\t\t( typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement ) ||\r\n\t\t\t\t\t( typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap ) ||\r\n\t\t\t\t\t( typeof OffscreenCanvas !== 'undefined' && image instanceof OffscreenCanvas ) ) {\r\n\r\n\t\t\t\t\tctx.drawImage( image, 0, 0, canvas.width, canvas.height );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tthrow new Error( 'THREE.GLTFExporter: Invalid image type. Use HTMLImageElement, HTMLCanvasElement, ImageBitmap or OffscreenCanvas.' );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( options.binary === true ) {\r\n\r\n\t\t\t\tpending.push(\r\n\r\n\t\t\t\t\tgetToBlobPromise( canvas, mimeType )\r\n\t\t\t\t\t\t.then( blob => writer.processBufferViewImage( blob ) )\r\n\t\t\t\t\t\t.then( bufferViewIndex => {\r\n\r\n\t\t\t\t\t\t\timageDef.bufferView = bufferViewIndex;\r\n\r\n\t\t\t\t\t\t} )\r\n\r\n\t\t\t\t);\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tif ( canvas.toDataURL !== undefined ) {\r\n\r\n\t\t\t\t\timageDef.uri = canvas.toDataURL( mimeType );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tpending.push(\r\n\r\n\t\t\t\t\t\tgetToBlobPromise( canvas, mimeType )\r\n\t\t\t\t\t\t\t.then( blob => new FileReader().readAsDataURL( blob ) )\r\n\t\t\t\t\t\t\t.then( dataURL => {\r\n\r\n\t\t\t\t\t\t\t\timageDef.uri = dataURL;\r\n\r\n\t\t\t\t\t\t\t} )\r\n\r\n\t\t\t\t\t);\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconst index = json.images.push( imageDef ) - 1;\r\n\t\t\tcachedImages[ key ] = index;\r\n\t\t\treturn index;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthrow new Error( 'THREE.GLTFExporter: No valid image data found. Unable to process texture.' );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Process sampler\r\n\t * @param  {Texture} map Texture to process\r\n\t * @return {Integer}     Index of the processed texture in the \"samplers\" array\r\n\t */\r\n\tprocessSampler( map ) {\r\n\r\n\t\tconst json = this.json;\r\n\r\n\t\tif ( ! json.samplers ) json.samplers = [];\r\n\r\n\t\tconst samplerDef = {\r\n\t\t\tmagFilter: THREE_TO_WEBGL[ map.magFilter ],\r\n\t\t\tminFilter: THREE_TO_WEBGL[ map.minFilter ],\r\n\t\t\twrapS: THREE_TO_WEBGL[ map.wrapS ],\r\n\t\t\twrapT: THREE_TO_WEBGL[ map.wrapT ]\r\n\t\t};\r\n\r\n\t\treturn json.samplers.push( samplerDef ) - 1;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Process texture\r\n\t * @param  {Texture} map Map to process\r\n\t * @return {Integer} Index of the processed texture in the \"textures\" array\r\n\t */\r\n\tasync processTextureAsync( map ) {\r\n\r\n\t\tconst writer = this;\r\n\t\tconst options = writer.options;\r\n\t\tconst cache = this.cache;\r\n\t\tconst json = this.json;\r\n\r\n\t\tif ( cache.textures.has( map ) ) return cache.textures.get( map );\r\n\r\n\t\tif ( ! json.textures ) json.textures = [];\r\n\r\n\t\t// make non-readable textures (e.g. CompressedTexture) readable by blitting them into a new texture\r\n\t\tif ( map instanceof CompressedTexture ) {\r\n\r\n\t\t\tmap = await this.decompressTextureAsync( map, options.maxTextureSize );\r\n\r\n\t\t}\r\n\r\n\t\tlet mimeType = map.userData.mimeType;\r\n\r\n\t\tif ( mimeType === 'image/webp' ) mimeType = 'image/png';\r\n\r\n\t\tconst textureDef = {\r\n\t\t\tsampler: this.processSampler( map ),\r\n\t\t\tsource: this.processImage( map.image, map.format, map.flipY, mimeType )\r\n\t\t};\r\n\r\n\t\tif ( map.name ) textureDef.name = map.name;\r\n\r\n\t\tawait this._invokeAllAsync( async function ( ext ) {\r\n\r\n\t\t\text.writeTexture && await ext.writeTexture( map, textureDef );\r\n\r\n\t\t} );\r\n\r\n\t\tconst index = json.textures.push( textureDef ) - 1;\r\n\t\tcache.textures.set( map, index );\r\n\t\treturn index;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Process material\r\n\t * @param  {THREE.Material} material Material to process\r\n\t * @return {Integer|null} Index of the processed material in the \"materials\" array\r\n\t */\r\n\tasync processMaterialAsync( material ) {\r\n\r\n\t\tconst cache = this.cache;\r\n\t\tconst json = this.json;\r\n\r\n\t\tif ( cache.materials.has( material ) ) return cache.materials.get( material );\r\n\r\n\t\tif ( material.isShaderMaterial ) {\r\n\r\n\t\t\tconsole.warn( 'GLTFExporter: THREE.ShaderMaterial not supported.' );\r\n\t\t\treturn null;\r\n\r\n\t\t}\r\n\r\n\t\tif ( ! json.materials ) json.materials = [];\r\n\r\n\t\t// @QUESTION Should we avoid including any attribute that has the default value?\r\n\t\tconst materialDef = {\tpbrMetallicRoughness: {} };\r\n\r\n\t\tif ( material.isMeshStandardMaterial !== true && material.isMeshBasicMaterial !== true ) {\r\n\r\n\t\t\tconsole.warn( 'GLTFExporter: Use MeshStandardMaterial or MeshBasicMaterial for best results.' );\r\n\r\n\t\t}\r\n\r\n\t\t// pbrMetallicRoughness.baseColorFactor\r\n\t\tconst color = material.color.toArray().concat( [ material.opacity ] );\r\n\r\n\t\tif ( ! equalArray( color, [ 1, 1, 1, 1 ] ) ) {\r\n\r\n\t\t\tmaterialDef.pbrMetallicRoughness.baseColorFactor = color;\r\n\r\n\t\t}\r\n\r\n\t\tif ( material.isMeshStandardMaterial ) {\r\n\r\n\t\t\tmaterialDef.pbrMetallicRoughness.metallicFactor = material.metalness;\r\n\t\t\tmaterialDef.pbrMetallicRoughness.roughnessFactor = material.roughness;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tmaterialDef.pbrMetallicRoughness.metallicFactor = 0;\r\n\t\t\tmaterialDef.pbrMetallicRoughness.roughnessFactor = 1;\r\n\r\n\t\t}\r\n\r\n\t\t// pbrMetallicRoughness.metallicRoughnessTexture\r\n\t\tif ( material.metalnessMap || material.roughnessMap ) {\r\n\r\n\t\t\tconst metalRoughTexture = await this.buildMetalRoughTextureAsync( material.metalnessMap, material.roughnessMap );\r\n\r\n\t\t\tconst metalRoughMapDef = {\r\n\t\t\t\tindex: await this.processTextureAsync( metalRoughTexture ),\r\n\t\t\t\ttexCoord: metalRoughTexture.channel\r\n\t\t\t};\r\n\t\t\tthis.applyTextureTransform( metalRoughMapDef, metalRoughTexture );\r\n\t\t\tmaterialDef.pbrMetallicRoughness.metallicRoughnessTexture = metalRoughMapDef;\r\n\r\n\t\t}\r\n\r\n\t\t// pbrMetallicRoughness.baseColorTexture\r\n\t\tif ( material.map ) {\r\n\r\n\t\t\tconst baseColorMapDef = {\r\n\t\t\t\tindex: await this.processTextureAsync( material.map ),\r\n\t\t\t\ttexCoord: material.map.channel\r\n\t\t\t};\r\n\t\t\tthis.applyTextureTransform( baseColorMapDef, material.map );\r\n\t\t\tmaterialDef.pbrMetallicRoughness.baseColorTexture = baseColorMapDef;\r\n\r\n\t\t}\r\n\r\n\t\tif ( material.emissive ) {\r\n\r\n\t\t\tconst emissive = material.emissive;\r\n\t\t\tconst maxEmissiveComponent = Math.max( emissive.r, emissive.g, emissive.b );\r\n\r\n\t\t\tif ( maxEmissiveComponent > 0 ) {\r\n\r\n\t\t\t\tmaterialDef.emissiveFactor = material.emissive.toArray();\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// emissiveTexture\r\n\t\t\tif ( material.emissiveMap ) {\r\n\r\n\t\t\t\tconst emissiveMapDef = {\r\n\t\t\t\t\tindex: await this.processTextureAsync( material.emissiveMap ),\r\n\t\t\t\t\ttexCoord: material.emissiveMap.channel\r\n\t\t\t\t};\r\n\t\t\t\tthis.applyTextureTransform( emissiveMapDef, material.emissiveMap );\r\n\t\t\t\tmaterialDef.emissiveTexture = emissiveMapDef;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// normalTexture\r\n\t\tif ( material.normalMap ) {\r\n\r\n\t\t\tconst normalMapDef = {\r\n\t\t\t\tindex: await this.processTextureAsync( material.normalMap ),\r\n\t\t\t\ttexCoord: material.normalMap.channel\r\n\t\t\t};\r\n\r\n\t\t\tif ( material.normalScale && material.normalScale.x !== 1 ) {\r\n\r\n\t\t\t\t// glTF normal scale is univariate. Ignore `y`, which may be flipped.\r\n\t\t\t\t// Context: https://github.com/mrdoob/three.js/issues/11438#issuecomment-507003995\r\n\t\t\t\tnormalMapDef.scale = material.normalScale.x;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.applyTextureTransform( normalMapDef, material.normalMap );\r\n\t\t\tmaterialDef.normalTexture = normalMapDef;\r\n\r\n\t\t}\r\n\r\n\t\t// occlusionTexture\r\n\t\tif ( material.aoMap ) {\r\n\r\n\t\t\tconst occlusionMapDef = {\r\n\t\t\t\tindex: await this.processTextureAsync( material.aoMap ),\r\n\t\t\t\ttexCoord: material.aoMap.channel\r\n\t\t\t};\r\n\r\n\t\t\tif ( material.aoMapIntensity !== 1.0 ) {\r\n\r\n\t\t\t\tocclusionMapDef.strength = material.aoMapIntensity;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.applyTextureTransform( occlusionMapDef, material.aoMap );\r\n\t\t\tmaterialDef.occlusionTexture = occlusionMapDef;\r\n\r\n\t\t}\r\n\r\n\t\t// alphaMode\r\n\t\tif ( material.transparent ) {\r\n\r\n\t\t\tmaterialDef.alphaMode = 'BLEND';\r\n\r\n\t\t} else {\r\n\r\n\t\t\tif ( material.alphaTest > 0.0 ) {\r\n\r\n\t\t\t\tmaterialDef.alphaMode = 'MASK';\r\n\t\t\t\tmaterialDef.alphaCutoff = material.alphaTest;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// doubleSided\r\n\t\tif ( material.side === DoubleSide ) materialDef.doubleSided = true;\r\n\t\tif ( material.name !== '' ) materialDef.name = material.name;\r\n\r\n\t\tthis.serializeUserData( material, materialDef );\r\n\r\n\t\tawait this._invokeAllAsync( async function ( ext ) {\r\n\r\n\t\t\text.writeMaterialAsync && await ext.writeMaterialAsync( material, materialDef );\r\n\r\n\t\t} );\r\n\r\n\t\tconst index = json.materials.push( materialDef ) - 1;\r\n\t\tcache.materials.set( material, index );\r\n\t\treturn index;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Process mesh\r\n\t * @param  {THREE.Mesh} mesh Mesh to process\r\n\t * @return {Integer|null} Index of the processed mesh in the \"meshes\" array\r\n\t */\r\n\tasync processMeshAsync( mesh ) {\r\n\r\n\t\tconst cache = this.cache;\r\n\t\tconst json = this.json;\r\n\r\n\t\tconst meshCacheKeyParts = [ mesh.geometry.uuid ];\r\n\r\n\t\tif ( Array.isArray( mesh.material ) ) {\r\n\r\n\t\t\tfor ( let i = 0, l = mesh.material.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tmeshCacheKeyParts.push( mesh.material[ i ].uuid\t);\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tmeshCacheKeyParts.push( mesh.material.uuid );\r\n\r\n\t\t}\r\n\r\n\t\tconst meshCacheKey = meshCacheKeyParts.join( ':' );\r\n\r\n\t\tif ( cache.meshes.has( meshCacheKey ) ) return cache.meshes.get( meshCacheKey );\r\n\r\n\t\tconst geometry = mesh.geometry;\r\n\r\n\t\tlet mode;\r\n\r\n\t\t// Use the correct mode\r\n\t\tif ( mesh.isLineSegments ) {\r\n\r\n\t\t\tmode = WEBGL_CONSTANTS.LINES;\r\n\r\n\t\t} else if ( mesh.isLineLoop ) {\r\n\r\n\t\t\tmode = WEBGL_CONSTANTS.LINE_LOOP;\r\n\r\n\t\t} else if ( mesh.isLine ) {\r\n\r\n\t\t\tmode = WEBGL_CONSTANTS.LINE_STRIP;\r\n\r\n\t\t} else if ( mesh.isPoints ) {\r\n\r\n\t\t\tmode = WEBGL_CONSTANTS.POINTS;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tmode = mesh.material.wireframe ? WEBGL_CONSTANTS.LINES : WEBGL_CONSTANTS.TRIANGLES;\r\n\r\n\t\t}\r\n\r\n\t\tconst meshDef = {};\r\n\t\tconst attributes = {};\r\n\t\tconst primitives = [];\r\n\t\tconst targets = [];\r\n\r\n\t\t// Conversion between attributes names in threejs and gltf spec\r\n\t\tconst nameConversion = {\r\n\t\t\tuv: 'TEXCOORD_0',\r\n\t\t\tuv1: 'TEXCOORD_1',\r\n\t\t\tuv2: 'TEXCOORD_2',\r\n\t\t\tuv3: 'TEXCOORD_3',\r\n\t\t\tcolor: 'COLOR_0',\r\n\t\t\tskinWeight: 'WEIGHTS_0',\r\n\t\t\tskinIndex: 'JOINTS_0'\r\n\t\t};\r\n\r\n\t\tconst originalNormal = geometry.getAttribute( 'normal' );\r\n\r\n\t\tif ( originalNormal !== undefined && ! this.isNormalizedNormalAttribute( originalNormal ) ) {\r\n\r\n\t\t\tconsole.warn( 'THREE.GLTFExporter: Creating normalized normal attribute from the non-normalized one.' );\r\n\r\n\t\t\tgeometry.setAttribute( 'normal', this.createNormalizedNormalAttribute( originalNormal ) );\r\n\r\n\t\t}\r\n\r\n\t\t// @QUESTION Detect if .vertexColors = true?\r\n\t\t// For every attribute create an accessor\r\n\t\tlet modifiedAttribute = null;\r\n\r\n\t\tfor ( let attributeName in geometry.attributes ) {\r\n\r\n\t\t\t// Ignore morph target attributes, which are exported later.\r\n\t\t\tif ( attributeName.slice( 0, 5 ) === 'morph' ) continue;\r\n\r\n\t\t\tconst attribute = geometry.attributes[ attributeName ];\r\n\t\t\tattributeName = nameConversion[ attributeName ] || attributeName.toUpperCase();\r\n\r\n\t\t\t// Prefix all geometry attributes except the ones specifically\r\n\t\t\t// listed in the spec; non-spec attributes are considered custom.\r\n\t\t\tconst validVertexAttributes =\r\n\t\t\t\t\t/^(POSITION|NORMAL|TANGENT|TEXCOORD_\\d+|COLOR_\\d+|JOINTS_\\d+|WEIGHTS_\\d+)$/;\r\n\r\n\t\t\tif ( ! validVertexAttributes.test( attributeName ) ) attributeName = '_' + attributeName;\r\n\r\n\t\t\tif ( cache.attributes.has( this.getUID( attribute ) ) ) {\r\n\r\n\t\t\t\tattributes[ attributeName ] = cache.attributes.get( this.getUID( attribute ) );\r\n\t\t\t\tcontinue;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Enforce glTF vertex attribute requirements:\r\n\t\t\t// - JOINTS_0 must be UNSIGNED_BYTE or UNSIGNED_SHORT\r\n\t\t\t// - Only custom attributes may be INT or UNSIGNED_INT\r\n\t\t\tmodifiedAttribute = null;\r\n\t\t\tconst array = attribute.array;\r\n\r\n\t\t\tif ( attributeName === 'JOINTS_0' &&\r\n\t\t\t\t! ( array instanceof Uint16Array ) &&\r\n\t\t\t\t! ( array instanceof Uint8Array ) ) {\r\n\r\n\t\t\t\tconsole.warn( 'GLTFExporter: Attribute \"skinIndex\" converted to type UNSIGNED_SHORT.' );\r\n\t\t\t\tmodifiedAttribute = new BufferAttribute( new Uint16Array( array ), attribute.itemSize, attribute.normalized );\r\n\r\n\t\t\t} else if ( ( array instanceof Uint32Array || array instanceof Int32Array ) && ! attributeName.startsWith( '_' ) ) {\r\n\r\n\t\t\t\tconsole.warn( `GLTFExporter: Attribute \"${ attributeName }\" converted to type FLOAT.` );\r\n\t\t\t\tmodifiedAttribute = GLTFExporter.Utils.toFloat32BufferAttribute( attribute );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconst accessor = this.processAccessor( modifiedAttribute || attribute, geometry );\r\n\r\n\t\t\tif ( accessor !== null ) {\r\n\r\n\t\t\t\tif ( ! attributeName.startsWith( '_' ) ) {\r\n\r\n\t\t\t\t\tthis.detectMeshQuantization( attributeName, attribute );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tattributes[ attributeName ] = accessor;\r\n\t\t\t\tcache.attributes.set( this.getUID( attribute ), accessor );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( originalNormal !== undefined ) geometry.setAttribute( 'normal', originalNormal );\r\n\r\n\t\t// Skip if no exportable attributes found\r\n\t\tif ( Object.keys( attributes ).length === 0 ) return null;\r\n\r\n\t\t// Morph targets\r\n\t\tif ( mesh.morphTargetInfluences !== undefined && mesh.morphTargetInfluences.length > 0 ) {\r\n\r\n\t\t\tconst weights = [];\r\n\t\t\tconst targetNames = [];\r\n\t\t\tconst reverseDictionary = {};\r\n\r\n\t\t\tif ( mesh.morphTargetDictionary !== undefined ) {\r\n\r\n\t\t\t\tfor ( const key in mesh.morphTargetDictionary ) {\r\n\r\n\t\t\t\t\treverseDictionary[ mesh.morphTargetDictionary[ key ] ] = key;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor ( let i = 0; i < mesh.morphTargetInfluences.length; ++ i ) {\r\n\r\n\t\t\t\tconst target = {};\r\n\t\t\t\tlet warned = false;\r\n\r\n\t\t\t\tfor ( const attributeName in geometry.morphAttributes ) {\r\n\r\n\t\t\t\t\t// glTF 2.0 morph supports only POSITION/NORMAL/TANGENT.\r\n\t\t\t\t\t// Three.js doesn't support TANGENT yet.\r\n\r\n\t\t\t\t\tif ( attributeName !== 'position' && attributeName !== 'normal' ) {\r\n\r\n\t\t\t\t\t\tif ( ! warned ) {\r\n\r\n\t\t\t\t\t\t\tconsole.warn( 'GLTFExporter: Only POSITION and NORMAL morph are supported.' );\r\n\t\t\t\t\t\t\twarned = true;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tconst attribute = geometry.morphAttributes[ attributeName ][ i ];\r\n\t\t\t\t\tconst gltfAttributeName = attributeName.toUpperCase();\r\n\r\n\t\t\t\t\t// Three.js morph attribute has absolute values while the one of glTF has relative values.\r\n\t\t\t\t\t//\r\n\t\t\t\t\t// glTF 2.0 Specification:\r\n\t\t\t\t\t// https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#morph-targets\r\n\r\n\t\t\t\t\tconst baseAttribute = geometry.attributes[ attributeName ];\r\n\r\n\t\t\t\t\tif ( cache.attributes.has( this.getUID( attribute, true ) ) ) {\r\n\r\n\t\t\t\t\t\ttarget[ gltfAttributeName ] = cache.attributes.get( this.getUID( attribute, true ) );\r\n\t\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// Clones attribute not to override\r\n\t\t\t\t\tconst relativeAttribute = attribute.clone();\r\n\r\n\t\t\t\t\tif ( ! geometry.morphTargetsRelative ) {\r\n\r\n\t\t\t\t\t\tfor ( let j = 0, jl = attribute.count; j < jl; j ++ ) {\r\n\r\n\t\t\t\t\t\t\tfor ( let a = 0; a < attribute.itemSize; a ++ ) {\r\n\r\n\t\t\t\t\t\t\t\tif ( a === 0 ) relativeAttribute.setX( j, attribute.getX( j ) - baseAttribute.getX( j ) );\r\n\t\t\t\t\t\t\t\tif ( a === 1 ) relativeAttribute.setY( j, attribute.getY( j ) - baseAttribute.getY( j ) );\r\n\t\t\t\t\t\t\t\tif ( a === 2 ) relativeAttribute.setZ( j, attribute.getZ( j ) - baseAttribute.getZ( j ) );\r\n\t\t\t\t\t\t\t\tif ( a === 3 ) relativeAttribute.setW( j, attribute.getW( j ) - baseAttribute.getW( j ) );\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\ttarget[ gltfAttributeName ] = this.processAccessor( relativeAttribute, geometry );\r\n\t\t\t\t\tcache.attributes.set( this.getUID( baseAttribute, true ), target[ gltfAttributeName ] );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\ttargets.push( target );\r\n\r\n\t\t\t\tweights.push( mesh.morphTargetInfluences[ i ] );\r\n\r\n\t\t\t\tif ( mesh.morphTargetDictionary !== undefined ) targetNames.push( reverseDictionary[ i ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tmeshDef.weights = weights;\r\n\r\n\t\t\tif ( targetNames.length > 0 ) {\r\n\r\n\t\t\t\tmeshDef.extras = {};\r\n\t\t\t\tmeshDef.extras.targetNames = targetNames;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tconst isMultiMaterial = Array.isArray( mesh.material );\r\n\r\n\t\tif ( isMultiMaterial && geometry.groups.length === 0 ) return null;\r\n\r\n\t\tlet didForceIndices = false;\r\n\r\n\t\tif ( isMultiMaterial && geometry.index === null ) {\r\n\r\n\t\t\tconst indices = [];\r\n\r\n\t\t\tfor ( let i = 0, il = geometry.attributes.position.count; i < il; i ++ ) {\r\n\r\n\t\t\t\tindices[ i ] = i;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tgeometry.setIndex( indices );\r\n\r\n\t\t\tdidForceIndices = true;\r\n\r\n\t\t}\r\n\r\n\t\tconst materials = isMultiMaterial ? mesh.material : [ mesh.material ];\r\n\t\tconst groups = isMultiMaterial ? geometry.groups : [ { materialIndex: 0, start: undefined, count: undefined } ];\r\n\r\n\t\tfor ( let i = 0, il = groups.length; i < il; i ++ ) {\r\n\r\n\t\t\tconst primitive = {\r\n\t\t\t\tmode: mode,\r\n\t\t\t\tattributes: attributes,\r\n\t\t\t};\r\n\r\n\t\t\tthis.serializeUserData( geometry, primitive );\r\n\r\n\t\t\tif ( targets.length > 0 ) primitive.targets = targets;\r\n\r\n\t\t\tif ( geometry.index !== null ) {\r\n\r\n\t\t\t\tlet cacheKey = this.getUID( geometry.index );\r\n\r\n\t\t\t\tif ( groups[ i ].start !== undefined || groups[ i ].count !== undefined ) {\r\n\r\n\t\t\t\t\tcacheKey += ':' + groups[ i ].start + ':' + groups[ i ].count;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( cache.attributes.has( cacheKey ) ) {\r\n\r\n\t\t\t\t\tprimitive.indices = cache.attributes.get( cacheKey );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tprimitive.indices = this.processAccessor( geometry.index, geometry, groups[ i ].start, groups[ i ].count );\r\n\t\t\t\t\tcache.attributes.set( cacheKey, primitive.indices );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( primitive.indices === null ) delete primitive.indices;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconst material = await this.processMaterialAsync( materials[ groups[ i ].materialIndex ] );\r\n\r\n\t\t\tif ( material !== null ) primitive.material = material;\r\n\r\n\t\t\tprimitives.push( primitive );\r\n\r\n\t\t}\r\n\r\n\t\tif ( didForceIndices === true ) {\r\n\r\n\t\t\tgeometry.setIndex( null );\r\n\r\n\t\t}\r\n\r\n\t\tmeshDef.primitives = primitives;\r\n\r\n\t\tif ( ! json.meshes ) json.meshes = [];\r\n\r\n\t\tawait this._invokeAllAsync( function ( ext ) {\r\n\r\n\t\t\text.writeMesh && ext.writeMesh( mesh, meshDef );\r\n\r\n\t\t} );\r\n\r\n\t\tconst index = json.meshes.push( meshDef ) - 1;\r\n\t\tcache.meshes.set( meshCacheKey, index );\r\n\t\treturn index;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * If a vertex attribute with a\r\n\t * [non-standard data type](https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#meshes-overview)\r\n\t * is used, it is checked whether it is a valid data type according to the\r\n\t * [KHR_mesh_quantization](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_mesh_quantization/README.md)\r\n\t * extension.\r\n\t * In this case the extension is automatically added to the list of used extensions.\r\n\t *\r\n\t * @param {string} attributeName\r\n\t * @param {THREE.BufferAttribute} attribute\r\n\t */\r\n\tdetectMeshQuantization( attributeName, attribute ) {\r\n\r\n\t\tif ( this.extensionsUsed[ KHR_MESH_QUANTIZATION ] ) return;\r\n\r\n\t\tlet attrType = undefined;\r\n\r\n\t\tswitch ( attribute.array.constructor ) {\r\n\r\n\t\t\tcase Int8Array:\r\n\r\n\t\t\t\tattrType = 'byte';\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase Uint8Array:\r\n\r\n\t\t\t\tattrType = 'unsigned byte';\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase Int16Array:\r\n\r\n\t\t\t\tattrType = 'short';\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase Uint16Array:\r\n\r\n\t\t\t\tattrType = 'unsigned short';\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tdefault:\r\n\r\n\t\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\tif ( attribute.normalized ) attrType += ' normalized';\r\n\r\n\t\tconst attrNamePrefix = attributeName.split( '_', 1 )[ 0 ];\r\n\r\n\t\tif ( KHR_mesh_quantization_ExtraAttrTypes[ attrNamePrefix ] && KHR_mesh_quantization_ExtraAttrTypes[ attrNamePrefix ].includes( attrType ) ) {\r\n\r\n\t\t\tthis.extensionsUsed[ KHR_MESH_QUANTIZATION ] = true;\r\n\t\t\tthis.extensionsRequired[ KHR_MESH_QUANTIZATION ] = true;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Process camera\r\n\t * @param  {THREE.Camera} camera Camera to process\r\n\t * @return {Integer}      Index of the processed mesh in the \"camera\" array\r\n\t */\r\n\tprocessCamera( camera ) {\r\n\r\n\t\tconst json = this.json;\r\n\r\n\t\tif ( ! json.cameras ) json.cameras = [];\r\n\r\n\t\tconst isOrtho = camera.isOrthographicCamera;\r\n\r\n\t\tconst cameraDef = {\r\n\t\t\ttype: isOrtho ? 'orthographic' : 'perspective'\r\n\t\t};\r\n\r\n\t\tif ( isOrtho ) {\r\n\r\n\t\t\tcameraDef.orthographic = {\r\n\t\t\t\txmag: camera.right * 2,\r\n\t\t\t\tymag: camera.top * 2,\r\n\t\t\t\tzfar: camera.far <= 0 ? 0.001 : camera.far,\r\n\t\t\t\tznear: camera.near < 0 ? 0 : camera.near\r\n\t\t\t};\r\n\r\n\t\t} else {\r\n\r\n\t\t\tcameraDef.perspective = {\r\n\t\t\t\taspectRatio: camera.aspect,\r\n\t\t\t\tyfov: MathUtils.degToRad( camera.fov ),\r\n\t\t\t\tzfar: camera.far <= 0 ? 0.001 : camera.far,\r\n\t\t\t\tznear: camera.near < 0 ? 0 : camera.near\r\n\t\t\t};\r\n\r\n\t\t}\r\n\r\n\t\t// Question: Is saving \"type\" as name intentional?\r\n\t\tif ( camera.name !== '' ) cameraDef.name = camera.type;\r\n\r\n\t\treturn json.cameras.push( cameraDef ) - 1;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Creates glTF animation entry from AnimationClip object.\r\n\t *\r\n\t * Status:\r\n\t * - Only properties listed in PATH_PROPERTIES may be animated.\r\n\t *\r\n\t * @param {THREE.AnimationClip} clip\r\n\t * @param {THREE.Object3D} root\r\n\t * @return {number|null}\r\n\t */\r\n\tprocessAnimation( clip, root ) {\r\n\r\n\t\tconst json = this.json;\r\n\t\tconst nodeMap = this.nodeMap;\r\n\r\n\t\tif ( ! json.animations ) json.animations = [];\r\n\r\n\t\tclip = GLTFExporter.Utils.mergeMorphTargetTracks( clip.clone(), root );\r\n\r\n\t\tconst tracks = clip.tracks;\r\n\t\tconst channels = [];\r\n\t\tconst samplers = [];\r\n\r\n\t\tfor ( let i = 0; i < tracks.length; ++ i ) {\r\n\r\n\t\t\tconst track = tracks[ i ];\r\n\t\t\tconst trackBinding = PropertyBinding.parseTrackName( track.name );\r\n\t\t\tlet trackNode = PropertyBinding.findNode( root, trackBinding.nodeName );\r\n\t\t\tconst trackProperty = PATH_PROPERTIES[ trackBinding.propertyName ];\r\n\r\n\t\t\tif ( trackBinding.objectName === 'bones' ) {\r\n\r\n\t\t\t\tif ( trackNode.isSkinnedMesh === true ) {\r\n\r\n\t\t\t\t\ttrackNode = trackNode.skeleton.getBoneByName( trackBinding.objectIndex );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\ttrackNode = undefined;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( ! trackNode || ! trackProperty ) {\r\n\r\n\t\t\t\tconsole.warn( 'THREE.GLTFExporter: Could not export animation track \"%s\".', track.name );\r\n\t\t\t\tcontinue;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconst inputItemSize = 1;\r\n\t\t\tlet outputItemSize = track.values.length / track.times.length;\r\n\r\n\t\t\tif ( trackProperty === PATH_PROPERTIES.morphTargetInfluences ) {\r\n\r\n\t\t\t\toutputItemSize /= trackNode.morphTargetInfluences.length;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tlet interpolation;\r\n\r\n\t\t\t// @TODO export CubicInterpolant(InterpolateSmooth) as CUBICSPLINE\r\n\r\n\t\t\t// Detecting glTF cubic spline interpolant by checking factory method's special property\r\n\t\t\t// GLTFCubicSplineInterpolant is a custom interpolant and track doesn't return\r\n\t\t\t// valid value from .getInterpolation().\r\n\t\t\tif ( track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline === true ) {\r\n\r\n\t\t\t\tinterpolation = 'CUBICSPLINE';\r\n\r\n\t\t\t\t// itemSize of CUBICSPLINE keyframe is 9\r\n\t\t\t\t// (VEC3 * 3: inTangent, splineVertex, and outTangent)\r\n\t\t\t\t// but needs to be stored as VEC3 so dividing by 3 here.\r\n\t\t\t\toutputItemSize /= 3;\r\n\r\n\t\t\t} else if ( track.getInterpolation() === InterpolateDiscrete ) {\r\n\r\n\t\t\t\tinterpolation = 'STEP';\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tinterpolation = 'LINEAR';\r\n\r\n\t\t\t}\r\n\r\n\t\t\tsamplers.push( {\r\n\t\t\t\tinput: this.processAccessor( new BufferAttribute( track.times, inputItemSize ) ),\r\n\t\t\t\toutput: this.processAccessor( new BufferAttribute( track.values, outputItemSize ) ),\r\n\t\t\t\tinterpolation: interpolation\r\n\t\t\t} );\r\n\r\n\t\t\tchannels.push( {\r\n\t\t\t\tsampler: samplers.length - 1,\r\n\t\t\t\ttarget: {\r\n\t\t\t\t\tnode: nodeMap.get( trackNode ),\r\n\t\t\t\t\tpath: trackProperty\r\n\t\t\t\t}\r\n\t\t\t} );\r\n\r\n\t\t}\r\n\r\n\t\tjson.animations.push( {\r\n\t\t\tname: clip.name || 'clip_' + json.animations.length,\r\n\t\t\tsamplers: samplers,\r\n\t\t\tchannels: channels\r\n\t\t} );\r\n\r\n\t\treturn json.animations.length - 1;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * @param {THREE.Object3D} object\r\n\t * @return {number|null}\r\n\t */\r\n\t processSkin( object ) {\r\n\r\n\t\tconst json = this.json;\r\n\t\tconst nodeMap = this.nodeMap;\r\n\r\n\t\tconst node = json.nodes[ nodeMap.get( object ) ];\r\n\r\n\t\tconst skeleton = object.skeleton;\r\n\r\n\t\tif ( skeleton === undefined ) return null;\r\n\r\n\t\tconst rootJoint = object.skeleton.bones[ 0 ];\r\n\r\n\t\tif ( rootJoint === undefined ) return null;\r\n\r\n\t\tconst joints = [];\r\n\t\tconst inverseBindMatrices = new Float32Array( skeleton.bones.length * 16 );\r\n\t\tconst temporaryBoneInverse = new Matrix4();\r\n\r\n\t\tfor ( let i = 0; i < skeleton.bones.length; ++ i ) {\r\n\r\n\t\t\tjoints.push( nodeMap.get( skeleton.bones[ i ] ) );\r\n\t\t\ttemporaryBoneInverse.copy( skeleton.boneInverses[ i ] );\r\n\t\t\ttemporaryBoneInverse.multiply( object.bindMatrix ).toArray( inverseBindMatrices, i * 16 );\r\n\r\n\t\t}\r\n\r\n\t\tif ( json.skins === undefined ) json.skins = [];\r\n\r\n\t\tjson.skins.push( {\r\n\t\t\tinverseBindMatrices: this.processAccessor( new BufferAttribute( inverseBindMatrices, 16 ) ),\r\n\t\t\tjoints: joints,\r\n\t\t\tskeleton: nodeMap.get( rootJoint )\r\n\t\t} );\r\n\r\n\t\tconst skinIndex = node.skin = json.skins.length - 1;\r\n\r\n\t\treturn skinIndex;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Process Object3D node\r\n\t * @param  {THREE.Object3D} node Object3D to processNodeAsync\r\n\t * @return {Integer} Index of the node in the nodes list\r\n\t */\r\n\tasync processNodeAsync( object ) {\r\n\r\n\t\tconst json = this.json;\r\n\t\tconst options = this.options;\r\n\t\tconst nodeMap = this.nodeMap;\r\n\r\n\t\tif ( ! json.nodes ) json.nodes = [];\r\n\r\n\t\tconst nodeDef = {};\r\n\r\n\t\tif ( options.trs ) {\r\n\r\n\t\t\tconst rotation = object.quaternion.toArray();\r\n\t\t\tconst position = object.position.toArray();\r\n\t\t\tconst scale = object.scale.toArray();\r\n\r\n\t\t\tif ( ! equalArray( rotation, [ 0, 0, 0, 1 ] ) ) {\r\n\r\n\t\t\t\tnodeDef.rotation = rotation;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( ! equalArray( position, [ 0, 0, 0 ] ) ) {\r\n\r\n\t\t\t\tnodeDef.translation = position;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( ! equalArray( scale, [ 1, 1, 1 ] ) ) {\r\n\r\n\t\t\t\tnodeDef.scale = scale;\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tif ( object.matrixAutoUpdate ) {\r\n\r\n\t\t\t\tobject.updateMatrix();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( isIdentityMatrix( object.matrix ) === false ) {\r\n\r\n\t\t\t\tnodeDef.matrix = object.matrix.elements;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// We don't export empty strings name because it represents no-name in Three.js.\r\n\t\tif ( object.name !== '' ) nodeDef.name = String( object.name );\r\n\r\n\t\tthis.serializeUserData( object, nodeDef );\r\n\r\n\t\tif ( object.isMesh || object.isLine || object.isPoints ) {\r\n\r\n\t\t\tconst meshIndex = await this.processMeshAsync( object );\r\n\r\n\t\t\tif ( meshIndex !== null ) nodeDef.mesh = meshIndex;\r\n\r\n\t\t} else if ( object.isCamera ) {\r\n\r\n\t\t\tnodeDef.camera = this.processCamera( object );\r\n\r\n\t\t}\r\n\r\n\t\tif ( object.isSkinnedMesh ) this.skins.push( object );\r\n\r\n\t\tif ( object.children.length > 0 ) {\r\n\r\n\t\t\tconst children = [];\r\n\r\n\t\t\tfor ( let i = 0, l = object.children.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tconst child = object.children[ i ];\r\n\r\n\t\t\t\tif ( child.visible || options.onlyVisible === false ) {\r\n\r\n\t\t\t\t\tconst nodeIndex = await this.processNodeAsync( child );\r\n\r\n\t\t\t\t\tif ( nodeIndex !== null ) children.push( nodeIndex );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( children.length > 0 ) nodeDef.children = children;\r\n\r\n\t\t}\r\n\r\n\t\tawait this._invokeAllAsync( function ( ext ) {\r\n\r\n\t\t\text.writeNode && ext.writeNode( object, nodeDef );\r\n\r\n\t\t} );\r\n\r\n\t\tconst nodeIndex = json.nodes.push( nodeDef ) - 1;\r\n\t\tnodeMap.set( object, nodeIndex );\r\n\t\treturn nodeIndex;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Process Scene\r\n\t * @param  {Scene} node Scene to process\r\n\t */\r\n\tasync processSceneAsync( scene ) {\r\n\r\n\t\tconst json = this.json;\r\n\t\tconst options = this.options;\r\n\r\n\t\tif ( ! json.scenes ) {\r\n\r\n\t\t\tjson.scenes = [];\r\n\t\t\tjson.scene = 0;\r\n\r\n\t\t}\r\n\r\n\t\tconst sceneDef = {};\r\n\r\n\t\tif ( scene.name !== '' ) sceneDef.name = scene.name;\r\n\r\n\t\tjson.scenes.push( sceneDef );\r\n\r\n\t\tconst nodes = [];\r\n\r\n\t\tfor ( let i = 0, l = scene.children.length; i < l; i ++ ) {\r\n\r\n\t\t\tconst child = scene.children[ i ];\r\n\r\n\t\t\tif ( child.visible || options.onlyVisible === false ) {\r\n\r\n\t\t\t\tconst nodeIndex = await this.processNodeAsync( child );\r\n\r\n\t\t\t\tif ( nodeIndex !== null ) nodes.push( nodeIndex );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( nodes.length > 0 ) sceneDef.nodes = nodes;\r\n\r\n\t\tthis.serializeUserData( scene, sceneDef );\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Creates a Scene to hold a list of objects and parse it\r\n\t * @param  {Array} objects List of objects to process\r\n\t */\r\n\tasync processObjectsAsync( objects ) {\r\n\r\n\t\tconst scene = new Scene();\r\n\t\tscene.name = 'AuxScene';\r\n\r\n\t\tfor ( let i = 0; i < objects.length; i ++ ) {\r\n\r\n\t\t\t// We push directly to children instead of calling `add` to prevent\r\n\t\t\t// modify the .parent and break its original scene and hierarchy\r\n\t\t\tscene.children.push( objects[ i ] );\r\n\r\n\t\t}\r\n\r\n\t\tawait this.processSceneAsync( scene );\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * @param {THREE.Object3D|Array<THREE.Object3D>} input\r\n\t */\r\n\tasync processInputAsync( input ) {\r\n\r\n\t\tconst options = this.options;\r\n\r\n\t\tinput = input instanceof Array ? input : [ input ];\r\n\r\n\t\tawait this._invokeAllAsync( function ( ext ) {\r\n\r\n\t\t\text.beforeParse && ext.beforeParse( input );\r\n\r\n\t\t} );\r\n\r\n\t\tconst objectsWithoutScene = [];\r\n\r\n\t\tfor ( let i = 0; i < input.length; i ++ ) {\r\n\r\n\t\t\tif ( input[ i ] instanceof Scene ) {\r\n\r\n\t\t\t\tawait this.processSceneAsync( input[ i ] );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tobjectsWithoutScene.push( input[ i ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( objectsWithoutScene.length > 0 ) {\r\n\r\n\t\t\tawait this.processObjectsAsync( objectsWithoutScene );\r\n\r\n\t\t}\r\n\r\n\t\tfor ( let i = 0; i < this.skins.length; ++ i ) {\r\n\r\n\t\t\tthis.processSkin( this.skins[ i ] );\r\n\r\n\t\t}\r\n\r\n\t\tfor ( let i = 0; i < options.animations.length; ++ i ) {\r\n\r\n\t\t\tthis.processAnimation( options.animations[ i ], input[ 0 ] );\r\n\r\n\t\t}\r\n\r\n\t\tawait this._invokeAllAsync( function ( ext ) {\r\n\r\n\t\t\text.afterParse && ext.afterParse( input );\r\n\r\n\t\t} );\r\n\r\n\t}\r\n\r\n\tasync _invokeAllAsync( func ) {\r\n\r\n\t\tfor ( let i = 0, il = this.plugins.length; i < il; i ++ ) {\r\n\r\n\t\t\tawait func( this.plugins[ i ] );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\n/**\r\n * Punctual Lights Extension\r\n *\r\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_lights_punctual\r\n */\r\nclass GLTFLightExtension {\r\n\r\n\tconstructor( writer ) {\r\n\r\n\t\tthis.writer = writer;\r\n\t\tthis.name = 'KHR_lights_punctual';\r\n\r\n\t}\r\n\r\n\twriteNode( light, nodeDef ) {\r\n\r\n\t\tif ( ! light.isLight ) return;\r\n\r\n\t\tif ( ! light.isDirectionalLight && ! light.isPointLight && ! light.isSpotLight ) {\r\n\r\n\t\t\tconsole.warn( 'THREE.GLTFExporter: Only directional, point, and spot lights are supported.', light );\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\tconst writer = this.writer;\r\n\t\tconst json = writer.json;\r\n\t\tconst extensionsUsed = writer.extensionsUsed;\r\n\r\n\t\tconst lightDef = {};\r\n\r\n\t\tif ( light.name ) lightDef.name = light.name;\r\n\r\n\t\tlightDef.color = light.color.toArray();\r\n\r\n\t\tlightDef.intensity = light.intensity;\r\n\r\n\t\tif ( light.isDirectionalLight ) {\r\n\r\n\t\t\tlightDef.type = 'directional';\r\n\r\n\t\t} else if ( light.isPointLight ) {\r\n\r\n\t\t\tlightDef.type = 'point';\r\n\r\n\t\t\tif ( light.distance > 0 ) lightDef.range = light.distance;\r\n\r\n\t\t} else if ( light.isSpotLight ) {\r\n\r\n\t\t\tlightDef.type = 'spot';\r\n\r\n\t\t\tif ( light.distance > 0 ) lightDef.range = light.distance;\r\n\r\n\t\t\tlightDef.spot = {};\r\n\t\t\tlightDef.spot.innerConeAngle = ( 1.0 - light.penumbra ) * light.angle;\r\n\t\t\tlightDef.spot.outerConeAngle = light.angle;\r\n\r\n\t\t}\r\n\r\n\t\tif ( light.decay !== undefined && light.decay !== 2 ) {\r\n\r\n\t\t\tconsole.warn( 'THREE.GLTFExporter: Light decay may be lost. glTF is physically-based, '\r\n\t\t\t\t+ 'and expects light.decay=2.' );\r\n\r\n\t\t}\r\n\r\n\t\tif ( light.target\r\n\t\t\t\t&& ( light.target.parent !== light\r\n\t\t\t\t|| light.target.position.x !== 0\r\n\t\t\t\t|| light.target.position.y !== 0\r\n\t\t\t\t|| light.target.position.z !== - 1 ) ) {\r\n\r\n\t\t\tconsole.warn( 'THREE.GLTFExporter: Light direction may be lost. For best results, '\r\n\t\t\t\t+ 'make light.target a child of the light with position 0,0,-1.' );\r\n\r\n\t\t}\r\n\r\n\t\tif ( ! extensionsUsed[ this.name ] ) {\r\n\r\n\t\t\tjson.extensions = json.extensions || {};\r\n\t\t\tjson.extensions[ this.name ] = { lights: [] };\r\n\t\t\textensionsUsed[ this.name ] = true;\r\n\r\n\t\t}\r\n\r\n\t\tconst lights = json.extensions[ this.name ].lights;\r\n\t\tlights.push( lightDef );\r\n\r\n\t\tnodeDef.extensions = nodeDef.extensions || {};\r\n\t\tnodeDef.extensions[ this.name ] = { light: lights.length - 1 };\r\n\r\n\t}\r\n\r\n}\r\n\r\n/**\r\n * Unlit Materials Extension\r\n *\r\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_unlit\r\n */\r\nclass GLTFMaterialsUnlitExtension {\r\n\r\n\tconstructor( writer ) {\r\n\r\n\t\tthis.writer = writer;\r\n\t\tthis.name = 'KHR_materials_unlit';\r\n\r\n\t}\r\n\r\n\tasync writeMaterialAsync( material, materialDef ) {\r\n\r\n\t\tif ( ! material.isMeshBasicMaterial ) return;\r\n\r\n\t\tconst writer = this.writer;\r\n\t\tconst extensionsUsed = writer.extensionsUsed;\r\n\r\n\t\tmaterialDef.extensions = materialDef.extensions || {};\r\n\t\tmaterialDef.extensions[ this.name ] = {};\r\n\r\n\t\textensionsUsed[ this.name ] = true;\r\n\r\n\t\tmaterialDef.pbrMetallicRoughness.metallicFactor = 0.0;\r\n\t\tmaterialDef.pbrMetallicRoughness.roughnessFactor = 0.9;\r\n\r\n\t}\r\n\r\n}\r\n\r\n/**\r\n * Clearcoat Materials Extension\r\n *\r\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_clearcoat\r\n */\r\nclass GLTFMaterialsClearcoatExtension {\r\n\r\n\tconstructor( writer ) {\r\n\r\n\t\tthis.writer = writer;\r\n\t\tthis.name = 'KHR_materials_clearcoat';\r\n\r\n\t}\r\n\r\n\tasync writeMaterialAsync( material, materialDef ) {\r\n\r\n\t\tif ( ! material.isMeshPhysicalMaterial || material.clearcoat === 0 ) return;\r\n\r\n\t\tconst writer = this.writer;\r\n\t\tconst extensionsUsed = writer.extensionsUsed;\r\n\r\n\t\tconst extensionDef = {};\r\n\r\n\t\textensionDef.clearcoatFactor = material.clearcoat;\r\n\r\n\t\tif ( material.clearcoatMap ) {\r\n\r\n\t\t\tconst clearcoatMapDef = {\r\n\t\t\t\tindex: await writer.processTextureAsync( material.clearcoatMap ),\r\n\t\t\t\ttexCoord: material.clearcoatMap.channel\r\n\t\t\t};\r\n\t\t\twriter.applyTextureTransform( clearcoatMapDef, material.clearcoatMap );\r\n\t\t\textensionDef.clearcoatTexture = clearcoatMapDef;\r\n\r\n\t\t}\r\n\r\n\t\textensionDef.clearcoatRoughnessFactor = material.clearcoatRoughness;\r\n\r\n\t\tif ( material.clearcoatRoughnessMap ) {\r\n\r\n\t\t\tconst clearcoatRoughnessMapDef = {\r\n\t\t\t\tindex: await writer.processTextureAsync( material.clearcoatRoughnessMap ),\r\n\t\t\t\ttexCoord: material.clearcoatRoughnessMap.channel\r\n\t\t\t};\r\n\t\t\twriter.applyTextureTransform( clearcoatRoughnessMapDef, material.clearcoatRoughnessMap );\r\n\t\t\textensionDef.clearcoatRoughnessTexture = clearcoatRoughnessMapDef;\r\n\r\n\t\t}\r\n\r\n\t\tif ( material.clearcoatNormalMap ) {\r\n\r\n\t\t\tconst clearcoatNormalMapDef = {\r\n\t\t\t\tindex: await writer.processTextureAsync( material.clearcoatNormalMap ),\r\n\t\t\t\ttexCoord: material.clearcoatNormalMap.channel\r\n\t\t\t};\r\n\r\n\t\t\tif ( material.clearcoatNormalScale.x !== 1 ) clearcoatNormalMapDef.scale = material.clearcoatNormalScale.x;\r\n\r\n\t\t\twriter.applyTextureTransform( clearcoatNormalMapDef, material.clearcoatNormalMap );\r\n\t\t\textensionDef.clearcoatNormalTexture = clearcoatNormalMapDef;\r\n\r\n\t\t}\r\n\r\n\t\tmaterialDef.extensions = materialDef.extensions || {};\r\n\t\tmaterialDef.extensions[ this.name ] = extensionDef;\r\n\r\n\t\textensionsUsed[ this.name ] = true;\r\n\r\n\r\n\t}\r\n\r\n}\r\n\r\n/**\r\n * Materials dispersion Extension\r\n *\r\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_dispersion\r\n */\r\nclass GLTFMaterialsDispersionExtension {\r\n\r\n\tconstructor( writer ) {\r\n\r\n\t\tthis.writer = writer;\r\n\t\tthis.name = 'KHR_materials_dispersion';\r\n\r\n\t}\r\n\r\n\tasync writeMaterialAsync( material, materialDef ) {\r\n\r\n\t\tif ( ! material.isMeshPhysicalMaterial || material.dispersion === 0 ) return;\r\n\r\n\t\tconst writer = this.writer;\r\n\t\tconst extensionsUsed = writer.extensionsUsed;\r\n\r\n\t\tconst extensionDef = {};\r\n\r\n\t\textensionDef.dispersion = material.dispersion;\r\n\r\n\t\tmaterialDef.extensions = materialDef.extensions || {};\r\n\t\tmaterialDef.extensions[ this.name ] = extensionDef;\r\n\r\n\t\textensionsUsed[ this.name ] = true;\r\n\r\n\t}\r\n\r\n}\r\n\r\n/**\r\n * Iridescence Materials Extension\r\n *\r\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_iridescence\r\n */\r\nclass GLTFMaterialsIridescenceExtension {\r\n\r\n\tconstructor( writer ) {\r\n\r\n\t\tthis.writer = writer;\r\n\t\tthis.name = 'KHR_materials_iridescence';\r\n\r\n\t}\r\n\r\n\tasync writeMaterialAsync( material, materialDef ) {\r\n\r\n\t\tif ( ! material.isMeshPhysicalMaterial || material.iridescence === 0 ) return;\r\n\r\n\t\tconst writer = this.writer;\r\n\t\tconst extensionsUsed = writer.extensionsUsed;\r\n\r\n\t\tconst extensionDef = {};\r\n\r\n\t\textensionDef.iridescenceFactor = material.iridescence;\r\n\r\n\t\tif ( material.iridescenceMap ) {\r\n\r\n\t\t\tconst iridescenceMapDef = {\r\n\t\t\t\tindex: await writer.processTextureAsync( material.iridescenceMap ),\r\n\t\t\t\ttexCoord: material.iridescenceMap.channel\r\n\t\t\t};\r\n\t\t\twriter.applyTextureTransform( iridescenceMapDef, material.iridescenceMap );\r\n\t\t\textensionDef.iridescenceTexture = iridescenceMapDef;\r\n\r\n\t\t}\r\n\r\n\t\textensionDef.iridescenceIor = material.iridescenceIOR;\r\n\t\textensionDef.iridescenceThicknessMinimum = material.iridescenceThicknessRange[ 0 ];\r\n\t\textensionDef.iridescenceThicknessMaximum = material.iridescenceThicknessRange[ 1 ];\r\n\r\n\t\tif ( material.iridescenceThicknessMap ) {\r\n\r\n\t\t\tconst iridescenceThicknessMapDef = {\r\n\t\t\t\tindex: await writer.processTextureAsync( material.iridescenceThicknessMap ),\r\n\t\t\t\ttexCoord: material.iridescenceThicknessMap.channel\r\n\t\t\t};\r\n\t\t\twriter.applyTextureTransform( iridescenceThicknessMapDef, material.iridescenceThicknessMap );\r\n\t\t\textensionDef.iridescenceThicknessTexture = iridescenceThicknessMapDef;\r\n\r\n\t\t}\r\n\r\n\t\tmaterialDef.extensions = materialDef.extensions || {};\r\n\t\tmaterialDef.extensions[ this.name ] = extensionDef;\r\n\r\n\t\textensionsUsed[ this.name ] = true;\r\n\r\n\t}\r\n\r\n}\r\n\r\n/**\r\n * Transmission Materials Extension\r\n *\r\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_transmission\r\n */\r\nclass GLTFMaterialsTransmissionExtension {\r\n\r\n\tconstructor( writer ) {\r\n\r\n\t\tthis.writer = writer;\r\n\t\tthis.name = 'KHR_materials_transmission';\r\n\r\n\t}\r\n\r\n\tasync writeMaterialAsync( material, materialDef ) {\r\n\r\n\t\tif ( ! material.isMeshPhysicalMaterial || material.transmission === 0 ) return;\r\n\r\n\t\tconst writer = this.writer;\r\n\t\tconst extensionsUsed = writer.extensionsUsed;\r\n\r\n\t\tconst extensionDef = {};\r\n\r\n\t\textensionDef.transmissionFactor = material.transmission;\r\n\r\n\t\tif ( material.transmissionMap ) {\r\n\r\n\t\t\tconst transmissionMapDef = {\r\n\t\t\t\tindex: await writer.processTextureAsync( material.transmissionMap ),\r\n\t\t\t\ttexCoord: material.transmissionMap.channel\r\n\t\t\t};\r\n\t\t\twriter.applyTextureTransform( transmissionMapDef, material.transmissionMap );\r\n\t\t\textensionDef.transmissionTexture = transmissionMapDef;\r\n\r\n\t\t}\r\n\r\n\t\tmaterialDef.extensions = materialDef.extensions || {};\r\n\t\tmaterialDef.extensions[ this.name ] = extensionDef;\r\n\r\n\t\textensionsUsed[ this.name ] = true;\r\n\r\n\t}\r\n\r\n}\r\n\r\n/**\r\n * Materials Volume Extension\r\n *\r\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_volume\r\n */\r\nclass GLTFMaterialsVolumeExtension {\r\n\r\n\tconstructor( writer ) {\r\n\r\n\t\tthis.writer = writer;\r\n\t\tthis.name = 'KHR_materials_volume';\r\n\r\n\t}\r\n\r\n\tasync writeMaterialAsync( material, materialDef ) {\r\n\r\n\t\tif ( ! material.isMeshPhysicalMaterial || material.transmission === 0 ) return;\r\n\r\n\t\tconst writer = this.writer;\r\n\t\tconst extensionsUsed = writer.extensionsUsed;\r\n\r\n\t\tconst extensionDef = {};\r\n\r\n\t\textensionDef.thicknessFactor = material.thickness;\r\n\r\n\t\tif ( material.thicknessMap ) {\r\n\r\n\t\t\tconst thicknessMapDef = {\r\n\t\t\t\tindex: await writer.processTextureAsync( material.thicknessMap ),\r\n\t\t\t\ttexCoord: material.thicknessMap.channel\r\n\t\t\t};\r\n\t\t\twriter.applyTextureTransform( thicknessMapDef, material.thicknessMap );\r\n\t\t\textensionDef.thicknessTexture = thicknessMapDef;\r\n\r\n\t\t}\r\n\r\n\t\tif ( material.attenuationDistance !== Infinity ) {\r\n\r\n\t\t\textensionDef.attenuationDistance = material.attenuationDistance;\r\n\r\n\t\t}\r\n\r\n\t\textensionDef.attenuationColor = material.attenuationColor.toArray();\r\n\r\n\t\tmaterialDef.extensions = materialDef.extensions || {};\r\n\t\tmaterialDef.extensions[ this.name ] = extensionDef;\r\n\r\n\t\textensionsUsed[ this.name ] = true;\r\n\r\n\t}\r\n\r\n}\r\n\r\n/**\r\n * Materials ior Extension\r\n *\r\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_ior\r\n */\r\nclass GLTFMaterialsIorExtension {\r\n\r\n\tconstructor( writer ) {\r\n\r\n\t\tthis.writer = writer;\r\n\t\tthis.name = 'KHR_materials_ior';\r\n\r\n\t}\r\n\r\n\tasync writeMaterialAsync( material, materialDef ) {\r\n\r\n\t\tif ( ! material.isMeshPhysicalMaterial || material.ior === 1.5 ) return;\r\n\r\n\t\tconst writer = this.writer;\r\n\t\tconst extensionsUsed = writer.extensionsUsed;\r\n\r\n\t\tconst extensionDef = {};\r\n\r\n\t\textensionDef.ior = material.ior;\r\n\r\n\t\tmaterialDef.extensions = materialDef.extensions || {};\r\n\t\tmaterialDef.extensions[ this.name ] = extensionDef;\r\n\r\n\t\textensionsUsed[ this.name ] = true;\r\n\r\n\t}\r\n\r\n}\r\n\r\n/**\r\n * Materials specular Extension\r\n *\r\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_specular\r\n */\r\nclass GLTFMaterialsSpecularExtension {\r\n\r\n\tconstructor( writer ) {\r\n\r\n\t\tthis.writer = writer;\r\n\t\tthis.name = 'KHR_materials_specular';\r\n\r\n\t}\r\n\r\n\tasync writeMaterialAsync( material, materialDef ) {\r\n\r\n\t\tif ( ! material.isMeshPhysicalMaterial || ( material.specularIntensity === 1.0 &&\r\n\t\t       material.specularColor.equals( DEFAULT_SPECULAR_COLOR ) &&\r\n\t\t     ! material.specularIntensityMap && ! material.specularColorMap ) ) return;\r\n\r\n\t\tconst writer = this.writer;\r\n\t\tconst extensionsUsed = writer.extensionsUsed;\r\n\r\n\t\tconst extensionDef = {};\r\n\r\n\t\tif ( material.specularIntensityMap ) {\r\n\r\n\t\t\tconst specularIntensityMapDef = {\r\n\t\t\t\tindex: await writer.processTextureAsync( material.specularIntensityMap ),\r\n\t\t\t\ttexCoord: material.specularIntensityMap.channel\r\n\t\t\t};\r\n\t\t\twriter.applyTextureTransform( specularIntensityMapDef, material.specularIntensityMap );\r\n\t\t\textensionDef.specularTexture = specularIntensityMapDef;\r\n\r\n\t\t}\r\n\r\n\t\tif ( material.specularColorMap ) {\r\n\r\n\t\t\tconst specularColorMapDef = {\r\n\t\t\t\tindex: await writer.processTextureAsync( material.specularColorMap ),\r\n\t\t\t\ttexCoord: material.specularColorMap.channel\r\n\t\t\t};\r\n\t\t\twriter.applyTextureTransform( specularColorMapDef, material.specularColorMap );\r\n\t\t\textensionDef.specularColorTexture = specularColorMapDef;\r\n\r\n\t\t}\r\n\r\n\t\textensionDef.specularFactor = material.specularIntensity;\r\n\t\textensionDef.specularColorFactor = material.specularColor.toArray();\r\n\r\n\t\tmaterialDef.extensions = materialDef.extensions || {};\r\n\t\tmaterialDef.extensions[ this.name ] = extensionDef;\r\n\r\n\t\textensionsUsed[ this.name ] = true;\r\n\r\n\t}\r\n\r\n}\r\n\r\n/**\r\n * Sheen Materials Extension\r\n *\r\n * Specification: https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_sheen\r\n */\r\nclass GLTFMaterialsSheenExtension {\r\n\r\n\tconstructor( writer ) {\r\n\r\n\t\tthis.writer = writer;\r\n\t\tthis.name = 'KHR_materials_sheen';\r\n\r\n\t}\r\n\r\n\tasync writeMaterialAsync( material, materialDef ) {\r\n\r\n\t\tif ( ! material.isMeshPhysicalMaterial || material.sheen == 0.0 ) return;\r\n\r\n\t\tconst writer = this.writer;\r\n\t\tconst extensionsUsed = writer.extensionsUsed;\r\n\r\n\t\tconst extensionDef = {};\r\n\r\n\t\tif ( material.sheenRoughnessMap ) {\r\n\r\n\t\t\tconst sheenRoughnessMapDef = {\r\n\t\t\t\tindex: await writer.processTextureAsync( material.sheenRoughnessMap ),\r\n\t\t\t\ttexCoord: material.sheenRoughnessMap.channel\r\n\t\t\t};\r\n\t\t\twriter.applyTextureTransform( sheenRoughnessMapDef, material.sheenRoughnessMap );\r\n\t\t\textensionDef.sheenRoughnessTexture = sheenRoughnessMapDef;\r\n\r\n\t\t}\r\n\r\n\t\tif ( material.sheenColorMap ) {\r\n\r\n\t\t\tconst sheenColorMapDef = {\r\n\t\t\t\tindex: await writer.processTextureAsync( material.sheenColorMap ),\r\n\t\t\t\ttexCoord: material.sheenColorMap.channel\r\n\t\t\t};\r\n\t\t\twriter.applyTextureTransform( sheenColorMapDef, material.sheenColorMap );\r\n\t\t\textensionDef.sheenColorTexture = sheenColorMapDef;\r\n\r\n\t\t}\r\n\r\n\t\textensionDef.sheenRoughnessFactor = material.sheenRoughness;\r\n\t\textensionDef.sheenColorFactor = material.sheenColor.toArray();\r\n\r\n\t\tmaterialDef.extensions = materialDef.extensions || {};\r\n\t\tmaterialDef.extensions[ this.name ] = extensionDef;\r\n\r\n\t\textensionsUsed[ this.name ] = true;\r\n\r\n\t}\r\n\r\n}\r\n\r\n/**\r\n * Anisotropy Materials Extension\r\n *\r\n * Specification: https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_anisotropy\r\n */\r\nclass GLTFMaterialsAnisotropyExtension {\r\n\r\n\tconstructor( writer ) {\r\n\r\n\t\tthis.writer = writer;\r\n\t\tthis.name = 'KHR_materials_anisotropy';\r\n\r\n\t}\r\n\r\n\tasync writeMaterialAsync( material, materialDef ) {\r\n\r\n\t\tif ( ! material.isMeshPhysicalMaterial || material.anisotropy == 0.0 ) return;\r\n\r\n\t\tconst writer = this.writer;\r\n\t\tconst extensionsUsed = writer.extensionsUsed;\r\n\r\n\t\tconst extensionDef = {};\r\n\r\n\t\tif ( material.anisotropyMap ) {\r\n\r\n\t\t\tconst anisotropyMapDef = { index: await writer.processTextureAsync( material.anisotropyMap ) };\r\n\t\t\twriter.applyTextureTransform( anisotropyMapDef, material.anisotropyMap );\r\n\t\t\textensionDef.anisotropyTexture = anisotropyMapDef;\r\n\r\n\t\t}\r\n\r\n\t\textensionDef.anisotropyStrength = material.anisotropy;\r\n\t\textensionDef.anisotropyRotation = material.anisotropyRotation;\r\n\r\n\t\tmaterialDef.extensions = materialDef.extensions || {};\r\n\t\tmaterialDef.extensions[ this.name ] = extensionDef;\r\n\r\n\t\textensionsUsed[ this.name ] = true;\r\n\r\n\t}\r\n\r\n}\r\n\r\n/**\r\n * Materials Emissive Strength Extension\r\n *\r\n * Specification: https://github.com/KhronosGroup/glTF/blob/5768b3ce0ef32bc39cdf1bef10b948586635ead3/extensions/2.0/Khronos/KHR_materials_emissive_strength/README.md\r\n */\r\nclass GLTFMaterialsEmissiveStrengthExtension {\r\n\r\n\tconstructor( writer ) {\r\n\r\n\t\tthis.writer = writer;\r\n\t\tthis.name = 'KHR_materials_emissive_strength';\r\n\r\n\t}\r\n\r\n\tasync writeMaterialAsync( material, materialDef ) {\r\n\r\n\t\tif ( ! material.isMeshStandardMaterial || material.emissiveIntensity === 1.0 ) return;\r\n\r\n\t\tconst writer = this.writer;\r\n\t\tconst extensionsUsed = writer.extensionsUsed;\r\n\r\n\t\tconst extensionDef = {};\r\n\r\n\t\textensionDef.emissiveStrength = material.emissiveIntensity;\r\n\r\n\t\tmaterialDef.extensions = materialDef.extensions || {};\r\n\t\tmaterialDef.extensions[ this.name ] = extensionDef;\r\n\r\n\t\textensionsUsed[ this.name ] = true;\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n/**\r\n * Materials bump Extension\r\n *\r\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/EXT_materials_bump\r\n */\r\nclass GLTFMaterialsBumpExtension {\r\n\r\n\tconstructor( writer ) {\r\n\r\n\t\tthis.writer = writer;\r\n\t\tthis.name = 'EXT_materials_bump';\r\n\r\n\t}\r\n\r\n\tasync writeMaterialAsync( material, materialDef ) {\r\n\r\n\t\tif ( ! material.isMeshStandardMaterial || (\r\n\t\t       material.bumpScale === 1 &&\r\n\t\t     ! material.bumpMap ) ) return;\r\n\r\n\t\tconst writer = this.writer;\r\n\t\tconst extensionsUsed = writer.extensionsUsed;\r\n\r\n\t\tconst extensionDef = {};\r\n\r\n\t\tif ( material.bumpMap ) {\r\n\r\n\t\t\tconst bumpMapDef = {\r\n\t\t\t\tindex: await writer.processTextureAsync( material.bumpMap ),\r\n\t\t\t\ttexCoord: material.bumpMap.channel\r\n\t\t\t};\r\n\t\t\twriter.applyTextureTransform( bumpMapDef, material.bumpMap );\r\n\t\t\textensionDef.bumpTexture = bumpMapDef;\r\n\r\n\t\t}\r\n\r\n\t\textensionDef.bumpFactor = material.bumpScale;\r\n\r\n\t\tmaterialDef.extensions = materialDef.extensions || {};\r\n\t\tmaterialDef.extensions[ this.name ] = extensionDef;\r\n\r\n\t\textensionsUsed[ this.name ] = true;\r\n\r\n\t}\r\n\r\n}\r\n\r\n/**\r\n * GPU Instancing Extension\r\n *\r\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_mesh_gpu_instancing\r\n */\r\nclass GLTFMeshGpuInstancing {\r\n\r\n\tconstructor( writer ) {\r\n\r\n\t\tthis.writer = writer;\r\n\t\tthis.name = 'EXT_mesh_gpu_instancing';\r\n\r\n\t}\r\n\r\n\twriteNode( object, nodeDef ) {\r\n\r\n\t\tif ( ! object.isInstancedMesh ) return;\r\n\r\n\t\tconst writer = this.writer;\r\n\r\n\t\tconst mesh = object;\r\n\r\n\t\tconst translationAttr = new Float32Array( mesh.count * 3 );\r\n\t\tconst rotationAttr = new Float32Array( mesh.count * 4 );\r\n\t\tconst scaleAttr = new Float32Array( mesh.count * 3 );\r\n\r\n\t\tconst matrix = new Matrix4();\r\n\t\tconst position = new Vector3();\r\n\t\tconst quaternion = new Quaternion();\r\n\t\tconst scale = new Vector3();\r\n\r\n\t\tfor ( let i = 0; i < mesh.count; i ++ ) {\r\n\r\n\t\t\tmesh.getMatrixAt( i, matrix );\r\n\t\t\tmatrix.decompose( position, quaternion, scale );\r\n\r\n\t\t\tposition.toArray( translationAttr, i * 3 );\r\n\t\t\tquaternion.toArray( rotationAttr, i * 4 );\r\n\t\t\tscale.toArray( scaleAttr, i * 3 );\r\n\r\n\t\t}\r\n\r\n\t\tconst attributes = {\r\n\t\t\tTRANSLATION: writer.processAccessor( new BufferAttribute( translationAttr, 3 ) ),\r\n\t\t\tROTATION: writer.processAccessor( new BufferAttribute( rotationAttr, 4 ) ),\r\n\t\t\tSCALE: writer.processAccessor( new BufferAttribute( scaleAttr, 3 ) ),\r\n\t\t};\r\n\r\n\t\tif ( mesh.instanceColor )\r\n\t\t\tattributes._COLOR_0 = writer.processAccessor( mesh.instanceColor );\r\n\r\n\t\tnodeDef.extensions = nodeDef.extensions || {};\r\n\t\tnodeDef.extensions[ this.name ] = { attributes };\r\n\r\n\t\twriter.extensionsUsed[ this.name ] = true;\r\n\t\twriter.extensionsRequired[ this.name ] = true;\r\n\r\n\t}\r\n\r\n}\r\n\r\n/**\r\n * Static utility functions\r\n */\r\nGLTFExporter.Utils = {\r\n\r\n\tinsertKeyframe: function ( track, time ) {\r\n\r\n\t\tconst tolerance = 0.001; // 1ms\r\n\t\tconst valueSize = track.getValueSize();\r\n\r\n\t\tconst times = new track.TimeBufferType( track.times.length + 1 );\r\n\t\tconst values = new track.ValueBufferType( track.values.length + valueSize );\r\n\t\tconst interpolant = track.createInterpolant( new track.ValueBufferType( valueSize ) );\r\n\r\n\t\tlet index;\r\n\r\n\t\tif ( track.times.length === 0 ) {\r\n\r\n\t\t\ttimes[ 0 ] = time;\r\n\r\n\t\t\tfor ( let i = 0; i < valueSize; i ++ ) {\r\n\r\n\t\t\t\tvalues[ i ] = 0;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tindex = 0;\r\n\r\n\t\t} else if ( time < track.times[ 0 ] ) {\r\n\r\n\t\t\tif ( Math.abs( track.times[ 0 ] - time ) < tolerance ) return 0;\r\n\r\n\t\t\ttimes[ 0 ] = time;\r\n\t\t\ttimes.set( track.times, 1 );\r\n\r\n\t\t\tvalues.set( interpolant.evaluate( time ), 0 );\r\n\t\t\tvalues.set( track.values, valueSize );\r\n\r\n\t\t\tindex = 0;\r\n\r\n\t\t} else if ( time > track.times[ track.times.length - 1 ] ) {\r\n\r\n\t\t\tif ( Math.abs( track.times[ track.times.length - 1 ] - time ) < tolerance ) {\r\n\r\n\t\t\t\treturn track.times.length - 1;\r\n\r\n\t\t\t}\r\n\r\n\t\t\ttimes[ times.length - 1 ] = time;\r\n\t\t\ttimes.set( track.times, 0 );\r\n\r\n\t\t\tvalues.set( track.values, 0 );\r\n\t\t\tvalues.set( interpolant.evaluate( time ), track.values.length );\r\n\r\n\t\t\tindex = times.length - 1;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tfor ( let i = 0; i < track.times.length; i ++ ) {\r\n\r\n\t\t\t\tif ( Math.abs( track.times[ i ] - time ) < tolerance ) return i;\r\n\r\n\t\t\t\tif ( track.times[ i ] < time && track.times[ i + 1 ] > time ) {\r\n\r\n\t\t\t\t\ttimes.set( track.times.slice( 0, i + 1 ), 0 );\r\n\t\t\t\t\ttimes[ i + 1 ] = time;\r\n\t\t\t\t\ttimes.set( track.times.slice( i + 1 ), i + 2 );\r\n\r\n\t\t\t\t\tvalues.set( track.values.slice( 0, ( i + 1 ) * valueSize ), 0 );\r\n\t\t\t\t\tvalues.set( interpolant.evaluate( time ), ( i + 1 ) * valueSize );\r\n\t\t\t\t\tvalues.set( track.values.slice( ( i + 1 ) * valueSize ), ( i + 2 ) * valueSize );\r\n\r\n\t\t\t\t\tindex = i + 1;\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\ttrack.times = times;\r\n\t\ttrack.values = values;\r\n\r\n\t\treturn index;\r\n\r\n\t},\r\n\r\n\tmergeMorphTargetTracks: function ( clip, root ) {\r\n\r\n\t\tconst tracks = [];\r\n\t\tconst mergedTracks = {};\r\n\t\tconst sourceTracks = clip.tracks;\r\n\r\n\t\tfor ( let i = 0; i < sourceTracks.length; ++ i ) {\r\n\r\n\t\t\tlet sourceTrack = sourceTracks[ i ];\r\n\t\t\tconst sourceTrackBinding = PropertyBinding.parseTrackName( sourceTrack.name );\r\n\t\t\tconst sourceTrackNode = PropertyBinding.findNode( root, sourceTrackBinding.nodeName );\r\n\r\n\t\t\tif ( sourceTrackBinding.propertyName !== 'morphTargetInfluences' || sourceTrackBinding.propertyIndex === undefined ) {\r\n\r\n\t\t\t\t// Tracks that don't affect morph targets, or that affect all morph targets together, can be left as-is.\r\n\t\t\t\ttracks.push( sourceTrack );\r\n\t\t\t\tcontinue;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( sourceTrack.createInterpolant !== sourceTrack.InterpolantFactoryMethodDiscrete\r\n\t\t\t\t&& sourceTrack.createInterpolant !== sourceTrack.InterpolantFactoryMethodLinear ) {\r\n\r\n\t\t\t\tif ( sourceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline ) {\r\n\r\n\t\t\t\t\t// This should never happen, because glTF morph target animations\r\n\t\t\t\t\t// affect all targets already.\r\n\t\t\t\t\tthrow new Error( 'THREE.GLTFExporter: Cannot merge tracks with glTF CUBICSPLINE interpolation.' );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tconsole.warn( 'THREE.GLTFExporter: Morph target interpolation mode not yet supported. Using LINEAR instead.' );\r\n\r\n\t\t\t\tsourceTrack = sourceTrack.clone();\r\n\t\t\t\tsourceTrack.setInterpolation( InterpolateLinear );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconst targetCount = sourceTrackNode.morphTargetInfluences.length;\r\n\t\t\tconst targetIndex = sourceTrackNode.morphTargetDictionary[ sourceTrackBinding.propertyIndex ];\r\n\r\n\t\t\tif ( targetIndex === undefined ) {\r\n\r\n\t\t\t\tthrow new Error( 'THREE.GLTFExporter: Morph target name not found: ' + sourceTrackBinding.propertyIndex );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tlet mergedTrack;\r\n\r\n\t\t\t// If this is the first time we've seen this object, create a new\r\n\t\t\t// track to store merged keyframe data for each morph target.\r\n\t\t\tif ( mergedTracks[ sourceTrackNode.uuid ] === undefined ) {\r\n\r\n\t\t\t\tmergedTrack = sourceTrack.clone();\r\n\r\n\t\t\t\tconst values = new mergedTrack.ValueBufferType( targetCount * mergedTrack.times.length );\r\n\r\n\t\t\t\tfor ( let j = 0; j < mergedTrack.times.length; j ++ ) {\r\n\r\n\t\t\t\t\tvalues[ j * targetCount + targetIndex ] = mergedTrack.values[ j ];\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// We need to take into consideration the intended target node\r\n\t\t\t\t// of our original un-merged morphTarget animation.\r\n\t\t\t\tmergedTrack.name = ( sourceTrackBinding.nodeName || '' ) + '.morphTargetInfluences';\r\n\t\t\t\tmergedTrack.values = values;\r\n\r\n\t\t\t\tmergedTracks[ sourceTrackNode.uuid ] = mergedTrack;\r\n\t\t\t\ttracks.push( mergedTrack );\r\n\r\n\t\t\t\tcontinue;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconst sourceInterpolant = sourceTrack.createInterpolant( new sourceTrack.ValueBufferType( 1 ) );\r\n\r\n\t\t\tmergedTrack = mergedTracks[ sourceTrackNode.uuid ];\r\n\r\n\t\t\t// For every existing keyframe of the merged track, write a (possibly\r\n\t\t\t// interpolated) value from the source track.\r\n\t\t\tfor ( let j = 0; j < mergedTrack.times.length; j ++ ) {\r\n\r\n\t\t\t\tmergedTrack.values[ j * targetCount + targetIndex ] = sourceInterpolant.evaluate( mergedTrack.times[ j ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// For every existing keyframe of the source track, write a (possibly\r\n\t\t\t// new) keyframe to the merged track. Values from the previous loop may\r\n\t\t\t// be written again, but keyframes are de-duplicated.\r\n\t\t\tfor ( let j = 0; j < sourceTrack.times.length; j ++ ) {\r\n\r\n\t\t\t\tconst keyframeIndex = this.insertKeyframe( mergedTrack, sourceTrack.times[ j ] );\r\n\t\t\t\tmergedTrack.values[ keyframeIndex * targetCount + targetIndex ] = sourceTrack.values[ j ];\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tclip.tracks = tracks;\r\n\r\n\t\treturn clip;\r\n\r\n\t},\r\n\r\n\ttoFloat32BufferAttribute: function ( srcAttribute ) {\r\n\r\n\t\tconst dstAttribute = new BufferAttribute( new Float32Array( srcAttribute.count * srcAttribute.itemSize ), srcAttribute.itemSize, false );\r\n\r\n\t\tif ( ! srcAttribute.normalized && ! srcAttribute.isInterleavedBufferAttribute ) {\r\n\r\n\t\t\tdstAttribute.array.set( srcAttribute.array );\r\n\r\n\t\t\treturn dstAttribute;\r\n\r\n\t\t}\r\n\r\n\t\tfor ( let i = 0, il = srcAttribute.count; i < il; i ++ ) {\r\n\r\n\t\t\tfor ( let j = 0; j < srcAttribute.itemSize; j ++ ) {\r\n\r\n\t\t\t\tdstAttribute.setComponent( i, j, srcAttribute.getComponent( i, j ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn dstAttribute;\r\n\r\n\t}\r\n\r\n};\r\n\r\nexport { GLTFExporter };\r\n"],
  "mappings": "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",
  "names": ["uids", "nodeIndex"]
}
