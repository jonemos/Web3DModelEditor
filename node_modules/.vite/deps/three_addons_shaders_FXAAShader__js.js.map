{
  "version": 3,
  "sources": ["../../three/examples/jsm/shaders/FXAAShader.js"],
  "sourcesContent": ["import {\r\n\tVector2\r\n} from 'three';\r\n\r\nconst FXAAShader = {\r\n\r\n\tname: 'FXAAShader',\r\n\r\n\tuniforms: {\r\n\r\n\t\t'tDiffuse': { value: null },\r\n\t\t'resolution': { value: new Vector2( 1 / 1024, 1 / 512 ) }\r\n\r\n\t},\r\n\r\n\tvertexShader: /* glsl */`\r\n\r\n\t\tvarying vec2 vUv;\r\n\r\n\t\tvoid main() {\r\n\r\n\t\t\tvUv = uv;\r\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\r\n\r\n\t\t}`,\r\n\r\n\tfragmentShader: /* glsl */`\r\n\r\n\t\t// FXAA algorithm from NVIDIA, C# implementation by Jasper Flick, GLSL port by Dave Hoskins\r\n\t\t// http://developer.download.nvidia.com/assets/gamedev/files/sdk/11/FXAA_WhitePaper.pdf\r\n\t\t// https://catlikecoding.com/unity/tutorials/advanced-rendering/fxaa/\r\n\r\n\t\tuniform sampler2D tDiffuse;\r\n\t\tuniform vec2 resolution;\r\n\t\tvarying vec2 vUv;\r\n\r\n\t\t#define EDGE_STEP_COUNT 6\r\n\t\t#define EDGE_GUESS 8.0\r\n\t\t#define EDGE_STEPS 1.0, 1.5, 2.0, 2.0, 2.0, 4.0\r\n\t\tconst float edgeSteps[EDGE_STEP_COUNT] = float[EDGE_STEP_COUNT]( EDGE_STEPS );\r\n\r\n\t\tfloat _ContrastThreshold = 0.0312;\r\n\t\tfloat _RelativeThreshold = 0.063;\r\n\t\tfloat _SubpixelBlending = 1.0;\r\n\r\n\t\tvec4 Sample( sampler2D  tex2D, vec2 uv ) {\r\n\r\n\t\t\treturn texture( tex2D, uv );\r\n\r\n\t\t}\r\n\r\n\t\tfloat SampleLuminance( sampler2D tex2D, vec2 uv ) {\r\n\r\n\t\t\treturn dot( Sample( tex2D, uv ).rgb, vec3( 0.3, 0.59, 0.11 ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat SampleLuminance( sampler2D tex2D, vec2 texSize, vec2 uv, float uOffset, float vOffset ) {\r\n\r\n\t\t\tuv += texSize * vec2(uOffset, vOffset);\r\n\t\t\treturn SampleLuminance(tex2D, uv);\r\n\r\n\t\t}\r\n\r\n\t\tstruct LuminanceData {\r\n\r\n\t\t\tfloat m, n, e, s, w;\r\n\t\t\tfloat ne, nw, se, sw;\r\n\t\t\tfloat highest, lowest, contrast;\r\n\r\n\t\t};\r\n\r\n\t\tLuminanceData SampleLuminanceNeighborhood( sampler2D tex2D, vec2 texSize, vec2 uv ) {\r\n\r\n\t\t\tLuminanceData l;\r\n\t\t\tl.m = SampleLuminance( tex2D, uv );\r\n\t\t\tl.n = SampleLuminance( tex2D, texSize, uv,  0.0,  1.0 );\r\n\t\t\tl.e = SampleLuminance( tex2D, texSize, uv,  1.0,  0.0 );\r\n\t\t\tl.s = SampleLuminance( tex2D, texSize, uv,  0.0, -1.0 );\r\n\t\t\tl.w = SampleLuminance( tex2D, texSize, uv, -1.0,  0.0 );\r\n\r\n\t\t\tl.ne = SampleLuminance( tex2D, texSize, uv,  1.0,  1.0 );\r\n\t\t\tl.nw = SampleLuminance( tex2D, texSize, uv, -1.0,  1.0 );\r\n\t\t\tl.se = SampleLuminance( tex2D, texSize, uv,  1.0, -1.0 );\r\n\t\t\tl.sw = SampleLuminance( tex2D, texSize, uv, -1.0, -1.0 );\r\n\r\n\t\t\tl.highest = max( max( max( max( l.n, l.e ), l.s ), l.w ), l.m );\r\n\t\t\tl.lowest = min( min( min( min( l.n, l.e ), l.s ), l.w ), l.m );\r\n\t\t\tl.contrast = l.highest - l.lowest;\r\n\t\t\treturn l;\r\n\r\n\t\t}\r\n\r\n\t\tbool ShouldSkipPixel( LuminanceData l ) {\r\n\r\n\t\t\tfloat threshold = max( _ContrastThreshold, _RelativeThreshold * l.highest );\r\n\t\t\treturn l.contrast < threshold;\r\n\r\n\t\t}\r\n\r\n\t\tfloat DeterminePixelBlendFactor( LuminanceData l ) {\r\n\r\n\t\t\tfloat f = 2.0 * ( l.n + l.e + l.s + l.w );\r\n\t\t\tf += l.ne + l.nw + l.se + l.sw;\r\n\t\t\tf *= 1.0 / 12.0;\r\n\t\t\tf = abs( f - l.m );\r\n\t\t\tf = clamp( f / l.contrast, 0.0, 1.0 );\r\n\r\n\t\t\tfloat blendFactor = smoothstep( 0.0, 1.0, f );\r\n\t\t\treturn blendFactor * blendFactor * _SubpixelBlending;\r\n\r\n\t\t}\r\n\r\n\t\tstruct EdgeData {\r\n\r\n\t\t\tbool isHorizontal;\r\n\t\t\tfloat pixelStep;\r\n\t\t\tfloat oppositeLuminance, gradient;\r\n\r\n\t\t};\r\n\r\n\t\tEdgeData DetermineEdge( vec2 texSize, LuminanceData l ) {\r\n\r\n\t\t\tEdgeData e;\r\n\t\t\tfloat horizontal =\r\n\t\t\t\tabs( l.n + l.s - 2.0 * l.m ) * 2.0 +\r\n\t\t\t\tabs( l.ne + l.se - 2.0 * l.e ) +\r\n\t\t\t\tabs( l.nw + l.sw - 2.0 * l.w );\r\n\t\t\tfloat vertical =\r\n\t\t\t\tabs( l.e + l.w - 2.0 * l.m ) * 2.0 +\r\n\t\t\t\tabs( l.ne + l.nw - 2.0 * l.n ) +\r\n\t\t\t\tabs( l.se + l.sw - 2.0 * l.s );\r\n\t\t\te.isHorizontal = horizontal >= vertical;\r\n\r\n\t\t\tfloat pLuminance = e.isHorizontal ? l.n : l.e;\r\n\t\t\tfloat nLuminance = e.isHorizontal ? l.s : l.w;\r\n\t\t\tfloat pGradient = abs( pLuminance - l.m );\r\n\t\t\tfloat nGradient = abs( nLuminance - l.m );\r\n\r\n\t\t\te.pixelStep = e.isHorizontal ? texSize.y : texSize.x;\r\n\t\t\t\r\n\t\t\tif (pGradient < nGradient) {\r\n\r\n\t\t\t\te.pixelStep = -e.pixelStep;\r\n\t\t\t\te.oppositeLuminance = nLuminance;\r\n\t\t\t\te.gradient = nGradient;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\te.oppositeLuminance = pLuminance;\r\n\t\t\t\te.gradient = pGradient;\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn e;\r\n\r\n\t\t}\r\n\r\n\t\tfloat DetermineEdgeBlendFactor( sampler2D  tex2D, vec2 texSize, LuminanceData l, EdgeData e, vec2 uv ) {\r\n\r\n\t\t\tvec2 uvEdge = uv;\r\n\t\t\tvec2 edgeStep;\r\n\t\t\tif (e.isHorizontal) {\r\n\r\n\t\t\t\tuvEdge.y += e.pixelStep * 0.5;\r\n\t\t\t\tedgeStep = vec2( texSize.x, 0.0 );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tuvEdge.x += e.pixelStep * 0.5;\r\n\t\t\t\tedgeStep = vec2( 0.0, texSize.y );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfloat edgeLuminance = ( l.m + e.oppositeLuminance ) * 0.5;\r\n\t\t\tfloat gradientThreshold = e.gradient * 0.25;\r\n\r\n\t\t\tvec2 puv = uvEdge + edgeStep * edgeSteps[0];\r\n\t\t\tfloat pLuminanceDelta = SampleLuminance( tex2D, puv ) - edgeLuminance;\r\n\t\t\tbool pAtEnd = abs( pLuminanceDelta ) >= gradientThreshold;\r\n\r\n\t\t\tfor ( int i = 1; i < EDGE_STEP_COUNT && !pAtEnd; i++ ) {\r\n\r\n\t\t\t\tpuv += edgeStep * edgeSteps[i];\r\n\t\t\t\tpLuminanceDelta = SampleLuminance( tex2D, puv ) - edgeLuminance;\r\n\t\t\t\tpAtEnd = abs( pLuminanceDelta ) >= gradientThreshold;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( !pAtEnd ) {\r\n\r\n\t\t\t\tpuv += edgeStep * EDGE_GUESS;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvec2 nuv = uvEdge - edgeStep * edgeSteps[0];\r\n\t\t\tfloat nLuminanceDelta = SampleLuminance( tex2D, nuv ) - edgeLuminance;\r\n\t\t\tbool nAtEnd = abs( nLuminanceDelta ) >= gradientThreshold;\r\n\r\n\t\t\tfor ( int i = 1; i < EDGE_STEP_COUNT && !nAtEnd; i++ ) {\r\n\r\n\t\t\t\tnuv -= edgeStep * edgeSteps[i];\r\n\t\t\t\tnLuminanceDelta = SampleLuminance( tex2D, nuv ) - edgeLuminance;\r\n\t\t\t\tnAtEnd = abs( nLuminanceDelta ) >= gradientThreshold;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( !nAtEnd ) {\r\n\r\n\t\t\t\tnuv -= edgeStep * EDGE_GUESS;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfloat pDistance, nDistance;\r\n\t\t\tif ( e.isHorizontal ) {\r\n\r\n\t\t\t\tpDistance = puv.x - uv.x;\r\n\t\t\t\tnDistance = uv.x - nuv.x;\r\n\r\n\t\t\t} else {\r\n\t\t\t\t\r\n\t\t\t\tpDistance = puv.y - uv.y;\r\n\t\t\t\tnDistance = uv.y - nuv.y;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfloat shortestDistance;\r\n\t\t\tbool deltaSign;\r\n\t\t\tif ( pDistance <= nDistance ) {\r\n\r\n\t\t\t\tshortestDistance = pDistance;\r\n\t\t\t\tdeltaSign = pLuminanceDelta >= 0.0;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tshortestDistance = nDistance;\r\n\t\t\t\tdeltaSign = nLuminanceDelta >= 0.0;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( deltaSign == ( l.m - edgeLuminance >= 0.0 ) ) {\r\n\r\n\t\t\t\treturn 0.0;\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn 0.5 - shortestDistance / ( pDistance + nDistance );\r\n\r\n\t\t}\r\n\r\n\t\tvec4 ApplyFXAA( sampler2D  tex2D, vec2 texSize, vec2 uv ) {\r\n\r\n\t\t\tLuminanceData luminance = SampleLuminanceNeighborhood( tex2D, texSize, uv );\r\n\t\t\tif ( ShouldSkipPixel( luminance ) ) {\r\n\r\n\t\t\t\treturn Sample( tex2D, uv );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfloat pixelBlend = DeterminePixelBlendFactor( luminance );\r\n\t\t\tEdgeData edge = DetermineEdge( texSize, luminance );\r\n\t\t\tfloat edgeBlend = DetermineEdgeBlendFactor( tex2D, texSize, luminance, edge, uv );\r\n\t\t\tfloat finalBlend = max( pixelBlend, edgeBlend );\r\n\r\n\t\t\tif (edge.isHorizontal) {\r\n\r\n\t\t\t\tuv.y += edge.pixelStep * finalBlend;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tuv.x += edge.pixelStep * finalBlend;\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn Sample( tex2D, uv );\r\n\r\n\t\t}\r\n\r\n\t\tvoid main() {\r\n\r\n\t\t\tgl_FragColor = ApplyFXAA( tDiffuse, resolution.xy, vUv );\r\n\t\t\t\r\n\t\t}`\r\n\r\n};\r\n\r\nexport { FXAAShader };\r\n"],
  "mappings": ";;;;;;AAIA,IAAM,aAAa;AAAA,EAElB,MAAM;AAAA,EAEN,UAAU;AAAA,IAET,YAAY,EAAE,OAAO,KAAK;AAAA,IAC1B,cAAc,EAAE,OAAO,IAAI,QAAS,IAAI,MAAM,IAAI,GAAI,EAAE;AAAA,EAEzD;AAAA,EAEA;AAAA;AAAA,IAAwB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAWxB;AAAA;AAAA,IAA0B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAkQ3B;",
  "names": []
}
